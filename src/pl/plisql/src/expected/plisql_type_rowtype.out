--
-- Tests for PL/iSQL %TYPE and and %ROWTYPE Attributes
--1 %TYPE
--1.1 If the declaration of the referenced item is changed, then the declaration of the referencing item changes accordingly.
--1.1.1 ALTER TABLE [ IF EXISTS ] [ ONLY ] name [ * ] ALTER [ COLUMN ] column_name [ SET DATA ] TYPE data_type [ COLLATE collation ] [ USING expression ]
--1.1.2 ALTER TABLE [ IF EXISTS ] [ ONLY ] name [ * ] DROP [ COLUMN ] [ IF EXISTS ] column_name [ RESTRICT | CASCADE ]
--1.1.3 ALTER TABLE [ IF EXISTS ] [ ONLY ] name [ * ] RENAME [ COLUMN ] column_name TO new_column_name
--1.1.4 ALTER TABLE [ IF EXISTS ] name  RENAME TO new_name
--1.1.5 DROP TABLE [ IF EXISTS ] name [, ...] [ CASCADE | RESTRICT ]
--1.2 The referencing variable inherits the Data type and size of the referenced variable
--1.3 The referencing variable inherits the Constraints (unless the referenced item is a column) of the referenced variable
--2 %ROWTYPE
--2.1 function's parameter datatype is tablename%ROWTYPE
--2.2 function's return datatype is tablename%ROWTYPE
--2.3 subprogram's parameter datatype and return datatype are tablename%ROWTYPE
--2.4 the referencing variable inherits the data type and size of the referenced variable
--2.5 if the declaration of the referenced item is changed, then the declaration of the referencing item changes accordingly.
--2.5.1 ALTER TABLE [ IF EXISTS ] [ ONLY ] name [ * ] ALTER [ COLUMN ] column_name [ SET DATA ] TYPE data_type [ COLLATE collation ] [ USING expression ]
--2.5.2 ALTER TABLE [ IF EXISTS ] [ ONLY ] name [ * ] DROP [ COLUMN ] [ IF EXISTS ] column_name [ RESTRICT | CASCADE ]
--2.5.3 ALTER TABLE [ IF EXISTS ] [ ONLY ] name [ * ] RENAME [ COLUMN ] column_name TO new_column_name
--2.5.4 ALTER TABLE [ IF EXISTS ] name  RENAME TO new_name
--2.5.5 DROP TABLE [ IF EXISTS ] name [, ...] [ CASCADE | RESTRICT ]
--3 INSERT INTO table_name VALUES var
--4 UPDATE table_name SET ROW = var [WHERE...]
--5 prostatus in pg_proc catalog
--6 all_arguments system views
--7 others
--
CREATE TABLE employees(first_name varchar(20) not null, 
last_name varchar(20) not null,
phone_number varchar(50));
INSERT INTO employees VALUES ('Steven','Niu','1-650-555-1234');
--1 %TYPE
--1.1 If the declaration of the referenced item is changed, then the declaration of the referencing item changes accordingly.
--1.1.1 ALTER TABLE [ IF EXISTS ] [ ONLY ] name [ * ] ALTER [ COLUMN ] column_name [ SET DATA ] TYPE data_type [ COLLATE collation ] [ USING expression ]
CREATE TABLE t1(id int, name varchar(20));
--function's parameter datatype is tablename.columnname%TYPE
CREATE OR REPLACE FUNCTION fun1(v t1.id%TYPE) RETURN varchar AS
BEGIN
  RETURN v;
END;
/
NOTICE:  type reference t1.id%TYPE converted to pg_catalog.int4
CREATE OR REPLACE PROCEDURE proc1(v t1.id%TYPE) AS
  a varchar(20);
BEGIN
  a := v;
  raise notice '%', a;
END;
/
NOTICE:  type reference t1.id%TYPE converted to pg_catalog.int4
SELECT prostatus FROM pg_proc WHERE proname like 'fun1'; --v
 prostatus 
-----------
 v
(1 row)

SELECT prostatus FROM pg_proc WHERE proname like 'proc1'; --v
 prostatus 
-----------
 v
(1 row)

SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE c.relname like 't1'
  AND d.refobjid = c.oid
  AND d.objid = p.oid
  AND p.proname like 'fun1';  --1
 count 
-------
     1
(1 row)

SELECT fun1(1) FROM dual;
 fun1 
------
 1
(1 row)

CALL proc1(1);
NOTICE:  1
ALTER TABLE t1 ALTER COLUMN id TYPE varchar(20);
SELECT prostatus FROM pg_proc WHERE proname like 'fun1'; --n
 prostatus 
-----------
 n
(1 row)

SELECT prostatus FROM pg_proc WHERE proname like 'proc1'; --n
 prostatus 
-----------
 n
(1 row)

SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE c.relname like 't1'
  AND d.refobjid = c.oid
  AND d.objid = p.oid
  AND p.proname like 'fun1'; --1
 count 
-------
     1
(1 row)

--after changing the column id type from int to varchar, call the function again
SELECT fun1('a') FROM dual;  --successfully
 fun1 
------
 a
(1 row)

ALTER FUNCTION fun1 COMPILE;
SELECT prostatus FROM pg_proc WHERE proname like 'fun1'; --v
 prostatus 
-----------
 v
(1 row)

SELECT fun1('a') FROM dual; --successfully
 fun1 
------
 a
(1 row)

CALL proc1('a');  --successfully
NOTICE:  a
ALTER PROCEDURE proc1 COMPILE;
SELECT prostatus FROM pg_proc WHERE proname like 'proc1'; --v
 prostatus 
-----------
 v
(1 row)

CALL proc1('a');  --successfully
NOTICE:  a
DROP FUNCTION fun1;
DROP PROCEDURE proc1;
DROP TABLE t1;
--function's return datatype is tablename.columnname%TYPE
CREATE TABLE t1(id varchar(20), name varchar(20));
CREATE OR REPLACE FUNCTION fun2(v int) RETURN t1.id%TYPE
AS
BEGIN
  RETURN 'a';
END;
/
NOTICE:  type reference t1.id%TYPE converted to varchar2
SELECT fun2(2) FROM dual;
 fun2 
------
 a
(1 row)

ALTER TABLE t1 ALTER COLUMN id TYPE integer using id::integer;
--because the column id type is changed from varchar to int, failed to call the function again
SELECT fun2(2) FROM dual; --failed
ERROR:  invalid input syntax for type integer: "a"
CONTEXT:  PL/iSQL function fun2(pg_catalog.int4) while casting return value to function's return type
ALTER FUNCTION fun2 COMPILE;
SELECT prostatus FROM pg_proc WHERE proname like 'fun2'; --v
 prostatus 
-----------
 v
(1 row)

SELECT fun2(2) FROM dual; --failed
ERROR:  invalid input syntax for type integer: "a"
CONTEXT:  PL/iSQL function fun2(pg_catalog.int4) while casting return value to function's return type
DROP FUNCTION fun2; 
DROP TABLE t1;
--Variable datatype is tablename.columnname%TYPE
CREATE TABLE t1(id varchar(20), name varchar(20));
CREATE OR REPLACE FUNCTION fun3(v int) RETURN varchar AS
  a t1.id%TYPE := 'a';
BEGIN
  RETURN a;
END;
/
CREATE OR REPLACE FUNCTION fun4(v int) RETURN varchar AS
  FUNCTION inf1(v1 int) RETURN varchar AS
    a t1.id%TYPE := 'a';
  BEGIN
    RETURN a;
  END;
BEGIN
  RETURN inf1(4);
END;
/
CREATE OR REPLACE FUNCTION fun5(v t1.id%TYPE) RETURN varchar AS
  PROCEDURE inp1(v1 t1.id%TYPE) AS
    a varchar(10);
  BEGIN
    a := v1;
    raise notice '%', a;
  END;
BEGIN
  CALL inp1(v);
  RETURN 'a';
END;
/
NOTICE:  type reference t1.id%TYPE converted to varchar2
SELECT fun3(3) FROM dual;
 fun3 
------
 a
(1 row)

SELECT fun4(4) FROM dual;
 fun4 
------
 a
(1 row)

SELECT fun5(5) FROM dual;
NOTICE:  5
 fun5 
------
 a
(1 row)

ALTER TABLE t1 ALTER COLUMN id TYPE integer using id::integer;
SELECT prostatus FROM pg_proc WHERE proname like 'fun3'; --n
 prostatus 
-----------
 n
(1 row)

SELECT prostatus FROM pg_proc WHERE proname like 'fun4'; --n
 prostatus 
-----------
 n
(1 row)

SELECT prostatus FROM pg_proc WHERE proname like 'fun5'; --n
 prostatus 
-----------
 n
(1 row)

SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE c.relname like 't1'
  AND d.refobjid = c.oid
  AND d.objid = p.oid
  AND p.proname like 'fun3'; --1
 count 
-------
     1
(1 row)

SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE c.relname like 't1'
  AND d.refobjid = c.oid
  AND d.objid = p.oid
  AND p.proname like 'fun4'; --1
 count 
-------
     1
(1 row)

SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE c.relname like 't1'
  AND d.refobjid = c.oid
  AND d.objid = p.oid
  AND p.proname like 'fun5'; --1
 count 
-------
     1
(1 row)

--change the column id type from int to varchar, call the function
SELECT fun3(3) FROM dual;  --failed
ERROR:  invalid input syntax for type integer: "a"
CONTEXT:  PL/iSQL function fun3(pg_catalog.int4) line 1 during statement block local variable initialization
SELECT fun4(4) FROM dual;  --failed
ERROR:  invalid input syntax for type integer: "a"
CONTEXT:  PL/iSQL function fun4(pg_catalog.int4) line 2 during statement block local variable initialization
SELECT fun5(5) FROM dual;  --successfully
NOTICE:  5
 fun5 
------
 a
(1 row)

ALTER FUNCTION fun3 COMPILE;
ALTER FUNCTION fun4 COMPILE;
ALTER FUNCTION fun5 COMPILE;
SELECT prostatus FROM pg_proc WHERE proname like 'fun3'; --v
 prostatus 
-----------
 v
(1 row)

SELECT prostatus FROM pg_proc WHERE proname like 'fun4'; --v
 prostatus 
-----------
 v
(1 row)

SELECT prostatus FROM pg_proc WHERE proname like 'fun5'; --v
 prostatus 
-----------
 v
(1 row)

SELECT fun3(3) FROM dual;  --failed
ERROR:  invalid input syntax for type integer: "a"
CONTEXT:  PL/iSQL function fun3(pg_catalog.int4) line 1 during statement block local variable initialization
SELECT fun4(4) FROM dual;  --failed
ERROR:  invalid input syntax for type integer: "a"
CONTEXT:  PL/iSQL function fun4(pg_catalog.int4) line 2 during statement block local variable initialization
SELECT fun5(5) FROM dual;  --successfully
NOTICE:  5
 fun5 
------
 a
(1 row)

DROP FUNCTION fun3; 
DROP FUNCTION fun4; 
DROP FUNCTION fun5; 
DROP TABLE t1;
--use tablename.columnname%TYPE in package
CREATE TABLE t1(id varchar(20), name varchar(20));
CREATE OR REPLACE PACKAGE pkg1 is
  var1 t1.id%TYPE;
  FUNCTION pfun(v int) return varchar;
END;
/
CREATE OR REPLACE PACKAGE BODY pkg1 is
   a t1.name%TYPE := 'a';
  FUNCTION pfun(v int) RETURN varchar AS
    a t1.id%TYPE := 'a';
	b a%TYPE := 'b';
  BEGIN
    var1 := 'a' || b;
    a := var1;
    RETURN a;
  END;
END;
/
DECLARE
BEGIN
  raise notice '%', pkg1.pfun(1);
END;
/
NOTICE:  ab
SELECT count(*) FROM pg_depend d, pg_class c, pg_package p 
  WHERE c.relname like 't1'
  AND d.refobjid = c.oid
  AND d.objid = p.oid
  AND p.pkgname like 'pkg1'; --1
 count 
-------
     1
(1 row)

  
ALTER TABLE t1 ALTER COLUMN id TYPE integer using id::integer;
--change the column id type from int to varchar, failed to call the package function again
select pkg1.pfun(1) from dual;  --should raise an error, packages has been discarded
ERROR:  existing state of packages has been discarded
DROP PACKAGE pkg1;
DROP TABLE t1;
--1.1.2 ALTER TABLE [ IF EXISTS ] [ ONLY ] name [ * ] DROP [ COLUMN ] [ IF EXISTS ] column_name [ RESTRICT | CASCADE ]
CREATE TABLE t1(id int, name varchar(20));
--function's parameter datatype is tablename.columnname%TYPE
CREATE OR REPLACE FUNCTION fun1(v t1.id%TYPE) RETURN varchar AS
BEGIN
  RETURN v;
END;
/
NOTICE:  type reference t1.id%TYPE converted to pg_catalog.int4
CREATE OR REPLACE PROCEDURE proc1(v t1.id%TYPE) AS
  a varchar(20);
BEGIN
  a := v;
  raise notice '%', a;
END;
/
NOTICE:  type reference t1.id%TYPE converted to pg_catalog.int4
SELECT fun1(1) FROM dual;
 fun1 
------
 1
(1 row)

CALL proc1(1);
NOTICE:  1
SELECT prostatus FROM pg_proc WHERE proname like 'fun1'; --v
 prostatus 
-----------
 v
(1 row)

SELECT prostatus FROM pg_proc WHERE proname like 'proc1'; --v
 prostatus 
-----------
 v
(1 row)

SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE c.relname like 't1'
  AND d.refobjid = c.oid
  AND d.objid = p.oid
  AND p.proname like 'fun1'; --1
 count 
-------
     1
(1 row)

SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE c.relname like 't1'
  AND d.refobjid = c.oid
  AND d.objid = p.oid
  AND p.proname like 'proc1'; --1
 count 
-------
     1
(1 row)

  
ALTER TABLE t1 DROP COLUMN id;
SELECT prostatus FROM pg_proc WHERE proname like 'fun1'; --n
 prostatus 
-----------
 n
(1 row)

SELECT prostatus FROM pg_proc WHERE proname like 'proc1'; --n
 prostatus 
-----------
 n
(1 row)

SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE c.relname like 't1'
  AND d.refobjid = c.oid
  AND d.objid = p.oid
  AND p.proname like 'fun1'; --0
 count 
-------
     0
(1 row)

SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE c.relname like 't1'
  AND d.refobjid = c.oid
  AND d.objid = p.oid
  AND p.proname like 'proc1'; --0
 count 
-------
     0
(1 row)

--after dropping the column id, failed to call the function
SELECT fun1('a') FROM dual; --failed
ERROR:  invalid input syntax for type integer: "a"
LINE 1: SELECT fun1('a') FROM dual;
                    ^
CALL proc1('a'); --failed
ERROR:  invalid input syntax for type integer: "a"
LINE 1: CALL proc1('a');
                   ^
ALTER FUNCTION fun1 COMPILE;
WARNING:  compilation error
HINT:  package, relation or view does not exist
ALTER PROCEDURE proc1 COMPILE;
WARNING:  compilation error
HINT:  package, relation or view does not exist
SELECT prostatus FROM pg_proc WHERE proname like 'fun1'; --i
 prostatus 
-----------
 i
(1 row)

SELECT prostatus FROM pg_proc WHERE proname like 'proc1'; --i
 prostatus 
-----------
 i
(1 row)

SELECT fun1('a') FROM dual; --failed
ERROR:  function fun1 is in invalid state
CALL proc1('a'); --failed
ERROR:  procedure proc1 is in invalid state
DROP TABLE t1;
DROP FUNCTION fun1;
DROP PROCEDURE proc1;
--function's return datatype is tablename.columnname%TYPE
CREATE TABLE t1(id varchar(20), name varchar(20));
CREATE OR REPLACE FUNCTION fun2(v int) RETURN t1.id%TYPE
AS
BEGIN
  RETURN 'a';
END;
/
NOTICE:  type reference t1.id%TYPE converted to varchar2
SELECT fun2(2) FROM dual;
 fun2 
------
 a
(1 row)

ALTER TABLE t1 DROP COLUMN id;
--after dropping the column id, failed to call the function again
SELECT fun2(2) FROM dual;
ERROR:  package, relation or view does not exist
LINE 1: SELECT fun2(2) FROM dual;
               ^
SELECT prostatus FROM pg_proc WHERE proname like 'fun2'; --i
 prostatus 
-----------
 n
(1 row)

SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE c.relname like 't1'
  AND d.refobjid = c.oid
  AND d.objid = p.oid
  AND p.proname like 'fun2'; --0
 count 
-------
     0
(1 row)

  
DROP TABLE t1;
DROP FUNCTION fun2; 
--Variable datatype is tablename.columnname%TYPE
CREATE TABLE t1(id varchar(20), name varchar(20));
CREATE OR REPLACE FUNCTION fun3(v int) RETURN varchar AS
  a t1.id%TYPE := 'a';
BEGIN
  RETURN a;
END;
/
CREATE OR REPLACE FUNCTION fun4(v int) RETURN varchar AS
  FUNCTION inf1(v1 int) RETURN varchar AS
    a t1.id%TYPE := 'a';
  BEGIN
    RETURN a;
  END;
BEGIN
  RETURN inf1(4);
END;
/
CREATE OR REPLACE FUNCTION fun5(v t1.id%TYPE) RETURN varchar AS
  PROCEDURE inp1(v1 t1.id%TYPE) AS
    a varchar(10);
  BEGIN
    a := v1;
    raise notice '%', a;
  END;
BEGIN
  CALL inp1(v);
  RETURN 'a';
END;
/
NOTICE:  type reference t1.id%TYPE converted to varchar2
SELECT fun3(3) FROM dual;
 fun3 
------
 a
(1 row)

SELECT fun4(4) FROM dual;
 fun4 
------
 a
(1 row)

SELECT fun5(5) FROM dual;
NOTICE:  5
 fun5 
------
 a
(1 row)

ALTER TABLE t1 DROP COLUMN id;
--after dropping the column id, call the function again
SELECT fun3(3) FROM dual;  --failed
ERROR:  column "id" of relation "t1" does not exist
CONTEXT:  compilation of PL/iSQL function "fun3" near line 1
SELECT fun4(4) FROM dual;  --failed
ERROR:  column "id" of relation "t1" does not exist
CONTEXT:  compilation of PL/iSQL function "fun4" near line 2
SELECT fun5(5) FROM dual;  --failed
ERROR:  package, relation or view does not exist
ALTER FUNCTION fun3 COMPILE;
WARNING:  compilation error
HINT:  column "id" of relation "t1" does not exist
ALTER FUNCTION fun4 COMPILE;
WARNING:  compilation error
HINT:  column "id" of relation "t1" does not exist
ALTER FUNCTION fun5 COMPILE;
WARNING:  compilation error
HINT:  package, relation or view does not exist
SELECT fun3(3) FROM dual;  --failed
ERROR:  function fun3 is in invalid state
SELECT fun4(4) FROM dual;  --failed
ERROR:  function fun4 is in invalid state
SELECT fun5(5) FROM dual;  --failed
ERROR:  function fun5 is in invalid state
DROP TABLE t1;
DROP FUNCTION fun3; 
DROP FUNCTION fun4; 
DROP FUNCTION fun5; 
--use tablename.columnname%TYPE in package
CREATE TABLE t1(id varchar(20), name varchar(20));
CREATE OR REPLACE PACKAGE pkg1 is
  var1 t1.id%TYPE;
  FUNCTION pfun(v int) return varchar;
END;
/
CREATE OR REPLACE PACKAGE BODY pkg1 is
  FUNCTION pfun(v int) RETURN varchar AS
    a t1.id%TYPE := 'a';
  BEGIN
    var1 := 'a';
    a := var1;
    RETURN a;
  END;
END;
/
DECLARE
BEGIN
  raise notice '%', pkg1.pfun(1);
END;
/
NOTICE:  a
ALTER TABLE t1 DROP COLUMN id;
--after dropping the column id, failed to call the package function again
DECLARE
BEGIN
  raise notice '%', pkg1.pfun(1);
END;
/
ERROR:  column "id" of relation "t1" does not exist
CONTEXT:  compilation of PL/iSQL package "pkg1" near line 1
compilation of PL/iSQL function "pkg1" near line 1
DROP PACKAGE pkg1;
DROP TABLE t1;
--inherit table
CREATE TABLE father_table(c1 integer,c2 varchar(10));
CREATE TABLE child_table(c3 varchar(10)) inherits (father_table);
CREATE OR REPLACE FUNCTION fun6(v int) return varchar as
  a child_table.c3%TYPE := 'a';
BEGIN
  RETURN a;
END;
/
SELECT fun6(1) FROM dual;
 fun6 
------
 a
(1 row)

ALTER TABLE child_table DROP COLUMN c3; 
SELECT fun6(1) FROM dual; --failed
ERROR:  column "c3" of relation "child_table" does not exist
CONTEXT:  compilation of PL/iSQL function "fun6" near line 1
ALTER FUNCTION fun6 COMPILE;
WARNING:  compilation error
HINT:  column "c3" of relation "child_table" does not exist
SELECT fun6(1) FROM dual; --failed
ERROR:  function fun6 is in invalid state
CREATE OR REPLACE FUNCTION fun7(v int) return varchar as
  a child_table.c2%TYPE := 'a';
BEGIN
  RETURN a;
END;
/
SELECT fun7(1) FROM dual;
 fun7 
------
 a
(1 row)

ALTER TABLE father_table DROP COLUMN c2; 
SELECT fun7(1) FROM dual; --failed
ERROR:  column "c2" of relation "child_table" does not exist
CONTEXT:  compilation of PL/iSQL function "fun7" near line 1
ALTER FUNCTION fun7 COMPILE;
WARNING:  compilation error
HINT:  column "c2" of relation "child_table" does not exist
SELECT fun7(1) FROM dual; --failed
ERROR:  function fun7 is in invalid state
DROP FUNCTION fun6;
DROP FUNCTION fun7;
DROP TABLE child_table;
DROP TABLE father_table;
--1.1.3 ALTER TABLE [ IF EXISTS ] [ ONLY ] name [ * ] RENAME [ COLUMN ] column_name TO new_column_name
CREATE TABLE t1(id int, name varchar(20));
--function's parameter datatype is tablename.columnname%TYPE
CREATE OR REPLACE FUNCTION fun1(v t1.id%TYPE) RETURN varchar AS
BEGIN
  RETURN v;
END;
/
NOTICE:  type reference t1.id%TYPE converted to pg_catalog.int4
CREATE OR REPLACE PROCEDURE proc1(v t1.id%TYPE) AS
  a varchar(20);
BEGIN
  a := v;
  raise notice '%', a;
END;
/
NOTICE:  type reference t1.id%TYPE converted to pg_catalog.int4
SELECT fun1(1) FROM dual;
 fun1 
------
 1
(1 row)

CALL proc1(1);
NOTICE:  1
ALTER TABLE t1 RENAME COLUMN id to id2;
--after renaming the column id to id2, failed to call the function again
SELECT fun1(1) FROM dual; --failed
ERROR:  package, relation or view does not exist
ALTER FUNCTION fun1 COMPILE;
WARNING:  compilation error
HINT:  package, relation or view does not exist
SELECT fun1(1) FROM dual; --failed
ERROR:  function fun1 is in invalid state
CALL proc1(1); --failed
ERROR:  package, relation or view does not exist
ALTER PROCEDURE proc1 COMPILE;
WARNING:  compilation error
HINT:  package, relation or view does not exist
CALL proc1(1); --failed
ERROR:  procedure proc1 is in invalid state
DROP TABLE t1;
DROP FUNCTION fun1;
DROP PROCEDURE proc1;
--function's return datatype is tablename.columnname%TYPE
CREATE TABLE t1(id varchar(20), name varchar(20));
CREATE OR REPLACE FUNCTION fun2(v int) RETURN t1.id%TYPE
AS
BEGIN
  RETURN 'a';
END;
/
NOTICE:  type reference t1.id%TYPE converted to varchar2
SELECT fun2(2) FROM dual;
 fun2 
------
 a
(1 row)

ALTER TABLE t1 RENAME COLUMN id to id2;
--after renaming the column id to id2, failed to call the function again
SELECT fun2(2) FROM dual; --failed
ERROR:  package, relation or view does not exist
LINE 1: SELECT fun2(2) FROM dual;
               ^
ALTER FUNCTION fun2 COMPILE;
WARNING:  compilation error
HINT:  package, relation or view does not exist
SELECT fun2(2) FROM dual; --failed
ERROR:  package, relation or view does not exist
LINE 1: SELECT fun2(2) FROM dual;
               ^
DROP TABLE t1;
DROP FUNCTION fun2; 
--Variable datatype is tablename.columnname%TYPE
CREATE TABLE t1(id varchar(20), name varchar(20));
CREATE OR REPLACE FUNCTION fun3(v int) RETURN varchar AS
  a t1.id%TYPE := 'a';
BEGIN
  RETURN a;
END;
/
CREATE OR REPLACE FUNCTION fun4(v int) RETURN varchar AS
  FUNCTION inf1(v1 int) RETURN varchar AS
    a t1.id%TYPE := 'a';
  BEGIN
    RETURN a;
  END;
BEGIN
  RETURN inf1(4);
END;
/
CREATE OR REPLACE FUNCTION fun5(v t1.id%TYPE) RETURN varchar AS
  PROCEDURE inp1(v1 t1.id%TYPE) AS
    a varchar(10);
  BEGIN
    a := v1;
    raise notice '%', a;
  END;
BEGIN
  CALL inp1(v);
  RETURN 'a';
END;
/
NOTICE:  type reference t1.id%TYPE converted to varchar2
SELECT fun3(3) FROM dual;
 fun3 
------
 a
(1 row)

SELECT fun4(4) FROM dual;
 fun4 
------
 a
(1 row)

SELECT fun5(5) FROM dual;
NOTICE:  5
 fun5 
------
 a
(1 row)

ALTER TABLE t1 RENAME COLUMN id to id2;
--after renaming the column id to id2, call the function again
SELECT fun3(3) FROM dual;  --failed
ERROR:  column "id" of relation "t1" does not exist
CONTEXT:  compilation of PL/iSQL function "fun3" near line 1
SELECT fun4(4) FROM dual;  --failed
ERROR:  column "id" of relation "t1" does not exist
CONTEXT:  compilation of PL/iSQL function "fun4" near line 2
SELECT fun5(5) FROM dual;  --failed
ERROR:  package, relation or view does not exist
ALTER FUNCTION fun3 COMPILE;
WARNING:  compilation error
HINT:  column "id" of relation "t1" does not exist
ALTER FUNCTION fun4 COMPILE;
WARNING:  compilation error
HINT:  column "id" of relation "t1" does not exist
ALTER FUNCTION fun5 COMPILE;
WARNING:  compilation error
HINT:  package, relation or view does not exist
SELECT fun3(3) FROM dual;  --failed
ERROR:  function fun3 is in invalid state
SELECT fun4(4) FROM dual;  --failed
ERROR:  function fun4 is in invalid state
SELECT fun5(5) FROM dual;  --failed
ERROR:  function fun5 is in invalid state
DROP TABLE t1;
DROP FUNCTION fun3; 
DROP FUNCTION fun4; 
DROP FUNCTION fun5; 
--use tablename.columnname%TYPE in package
CREATE TABLE t1(id varchar(20), name varchar(20));
CREATE OR REPLACE PACKAGE pkg1 is
  var1 t1.id%TYPE;
  FUNCTION pfun(v int) return varchar;
END;
/
CREATE OR REPLACE PACKAGE BODY pkg1 is
  FUNCTION pfun(v int) RETURN varchar AS
    a t1.id%TYPE := 'a';
  BEGIN
    var1 := 'a';
    a := var1;
    RETURN a;
  END;
END;
/
DECLARE
BEGIN
  raise notice '%', pkg1.pfun(1);
END;
/
NOTICE:  a
ALTER TABLE t1 RENAME COLUMN id to id2;
--after renaming the column id to id2, failed to call the package function again
DECLARE
BEGIN
  raise notice '%', pkg1.pfun(1);
END;
/
ERROR:  column "id" of relation "t1" does not exist
CONTEXT:  compilation of PL/iSQL package "pkg1" near line 1
compilation of PL/iSQL function "pkg1" near line 1
DROP PACKAGE pkg1;
DROP TABLE t1;
--inherit table
CREATE TABLE father_table(c1 integer,c2 varchar(10));
CREATE TABLE child_table(c3 varchar(10)) inherits (father_table);
CREATE OR REPLACE FUNCTION fun6(v int) return varchar as
  a child_table.c3%TYPE := 'a';
BEGIN
  RETURN a;
END;
/
SELECT fun6(1) FROM dual;
 fun6 
------
 a
(1 row)

ALTER FUNCTION fun6 COMPILE;
SELECT fun6(1) FROM dual;
 fun6 
------
 a
(1 row)

ALTER TABLE child_table RENAME COLUMN c3 to c4; 
SELECT fun6(1) FROM dual;
ERROR:  column "c3" of relation "child_table" does not exist
CONTEXT:  compilation of PL/iSQL function "fun6" near line 1
CREATE OR REPLACE FUNCTION fun7(v int) return varchar as
  a child_table.c2%TYPE := 'a';
BEGIN
  RETURN a;
END;
/
SELECT fun7(1) FROM dual;
 fun7 
------
 a
(1 row)

ALTER TABLE father_table RENAME COLUMN c2 to c2_new; 
SELECT fun7(1) FROM dual; --failed
ERROR:  column "c2" of relation "child_table" does not exist
CONTEXT:  compilation of PL/iSQL function "fun7" near line 1
ALTER FUNCTION fun7 COMPILE;
WARNING:  compilation error
HINT:  column "c2" of relation "child_table" does not exist
SELECT fun7(1) FROM dual; --failed
ERROR:  function fun7 is in invalid state
DROP FUNCTION fun6;
DROP FUNCTION fun7;
DROP TABLE child_table;
DROP TABLE father_table;
--1.1.4 ALTER TABLE [ IF EXISTS ] name  RENAME TO new_name
CREATE TABLE t1(id int, name varchar(20));
--function's parameter datatype is tablename.columnname%TYPE
CREATE OR REPLACE FUNCTION fun1(v t1.id%TYPE) RETURN varchar AS
BEGIN
  RETURN v;
END;
/
NOTICE:  type reference t1.id%TYPE converted to pg_catalog.int4
CREATE OR REPLACE PROCEDURE proc1(v t1.id%TYPE) AS
  a varchar(20);
BEGIN
  a := v;
  raise notice '%', a;
END;
/
NOTICE:  type reference t1.id%TYPE converted to pg_catalog.int4
SELECT fun1(1) FROM dual;
 fun1 
------
 1
(1 row)

CALL proc1(1);
NOTICE:  1
ALTER TABLE t1 RENAME TO t1_new;
--after renaming the table t1 to t1_new, failed to call the function again
SELECT fun1(1) FROM dual; --failed
ERROR:  package, relation or view does not exist
CALL proc1(1); --failed
ERROR:  package, relation or view does not exist
ALTER FUNCTION fun1 COMPILE;
WARNING:  compilation error
HINT:  package, relation or view does not exist
ALTER PROCEDURE proc1 COMPILE;
WARNING:  compilation error
HINT:  package, relation or view does not exist
SELECT fun1(1) FROM dual; --failed
ERROR:  function fun1 is in invalid state
CALL proc1(1); --failed
ERROR:  procedure proc1 is in invalid state
DROP TABLE t1_new;
DROP FUNCTION fun1;
DROP PROCEDURE proc1;
--function's return datatype is tablename.columnname%TYPE
CREATE TABLE t1(id varchar(20), name varchar(20));
CREATE OR REPLACE FUNCTION fun2(v int) RETURN t1.id%TYPE
AS
BEGIN
  RETURN 'a';
END;
/
NOTICE:  type reference t1.id%TYPE converted to varchar2
SELECT fun2(2) FROM dual;
 fun2 
------
 a
(1 row)

ALTER TABLE t1 RENAME TO t1_new;
--after renaming the table t1 to t1_new, failed to call the function again
SELECT fun2(2) FROM dual; --failed
ERROR:  package, relation or view does not exist
LINE 1: SELECT fun2(2) FROM dual;
               ^
ALTER FUNCTION fun2 COMPILE;
WARNING:  compilation error
HINT:  package, relation or view does not exist
SELECT fun2(2) FROM dual; --failed
ERROR:  package, relation or view does not exist
LINE 1: SELECT fun2(2) FROM dual;
               ^
DROP TABLE t1_new;
DROP FUNCTION fun2; 
--Variable datatype is tablename.columnname%TYPE
CREATE TABLE t1(id varchar(20), name varchar(20));
CREATE OR REPLACE FUNCTION fun3(v int) RETURN varchar AS
  a t1.id%TYPE := 'a';
BEGIN
  RETURN a;
END;
/
CREATE OR REPLACE FUNCTION fun4(v int) RETURN varchar AS
  FUNCTION inf1(v1 int) RETURN varchar AS
    a t1.id%TYPE := 'a';
  BEGIN
    RETURN a;
  END;
BEGIN
  RETURN inf1(4);
END;
/
CREATE OR REPLACE FUNCTION fun5(v t1.id%TYPE) RETURN varchar AS
  PROCEDURE inp1(v1 t1.id%TYPE) AS
    a varchar(10);
  BEGIN
    a := v1;
    raise notice '%', a;
  END;
BEGIN
  CALL inp1(v);
  RETURN 'a';
END;
/
NOTICE:  type reference t1.id%TYPE converted to varchar2
SELECT fun3(3) FROM dual;
 fun3 
------
 a
(1 row)

SELECT fun4(4) FROM dual;
 fun4 
------
 a
(1 row)

SELECT fun5(5) FROM dual;
NOTICE:  5
 fun5 
------
 a
(1 row)

ALTER TABLE t1 RENAME TO t1_new;
--after renaming the table t1 to t1_new, call the function again
SELECT fun3(3) FROM dual;  --failed
ERROR:  relation "t1" does not exist
CONTEXT:  compilation of PL/iSQL function "fun3" near line 1
SELECT fun4(4) FROM dual;  --failed
ERROR:  relation "t1" does not exist
CONTEXT:  compilation of PL/iSQL function "fun4" near line 2
SELECT fun5(5) FROM dual;  --failed
ERROR:  package, relation or view does not exist
ALTER FUNCTION fun3 COMPILE;
WARNING:  compilation error
HINT:  relation "t1" does not exist
ALTER FUNCTION fun4 COMPILE;
WARNING:  compilation error
HINT:  relation "t1" does not exist
ALTER FUNCTION fun5 COMPILE;
WARNING:  compilation error
HINT:  package, relation or view does not exist
SELECT fun3(3) FROM dual;  --failed
ERROR:  function fun3 is in invalid state
SELECT fun4(4) FROM dual;  --failed
ERROR:  function fun4 is in invalid state
SELECT fun5(5) FROM dual;  --failed
ERROR:  function fun5 is in invalid state
DROP TABLE t1_new;
DROP FUNCTION fun3; 
DROP FUNCTION fun4; 
DROP FUNCTION fun5; 
--use tablename.columnname%TYPE in package
CREATE TABLE t1(id varchar(20), name varchar(20));
CREATE OR REPLACE PACKAGE pkg1 is
  var1 t1.id%TYPE;
  FUNCTION pfun(v int) return varchar;
END;
/
CREATE OR REPLACE PACKAGE BODY pkg1 is
  FUNCTION pfun(v int) RETURN varchar AS
    a t1.id%TYPE := 'a';
  BEGIN
    var1 := 'a';
    a := var1;
    RETURN a;
  END;
END;
/
DECLARE
BEGIN
  raise notice '%', pkg1.pfun(1);
END;
/
NOTICE:  a
ALTER TABLE t1 RENAME TO t1_new;
--after renaming the table t1 to t1_new, failed to call the package function again
DECLARE
BEGIN
  raise notice '%', pkg1.pfun(1);
END;
/
ERROR:  relation "t1" does not exist
CONTEXT:  compilation of PL/iSQL package "pkg1" near line 1
compilation of PL/iSQL function "pkg1" near line 1
DROP PACKAGE pkg1;
DROP TABLE t1_new;
--inherit table
CREATE TABLE father_table(c1 integer,c2 varchar(10));
CREATE TABLE child_table(c3 varchar(10)) inherits (father_table);
CREATE OR REPLACE FUNCTION fun6(v int) return varchar as
  a child_table.c3%TYPE := 'a';
BEGIN
  RETURN a;
END;
/
SELECT fun6(1) FROM dual;
 fun6 
------
 a
(1 row)

ALTER TABLE child_table RENAME TO child_table_new;
SELECT fun6(1) FROM dual; --failed
ERROR:  relation "child_table" does not exist
CONTEXT:  compilation of PL/iSQL function "fun6" near line 1
ALTER FUNCTION fun6 COMPILE;
WARNING:  compilation error
HINT:  relation "child_table" does not exist
SELECT fun6(1) FROM dual; --failed
ERROR:  function fun6 is in invalid state
CREATE OR REPLACE FUNCTION fun7(v int) return varchar as
  a child_table_new.c2%TYPE := 'a';
BEGIN
  RETURN a;
END;
/
SELECT fun7(1) FROM dual;
 fun7 
------
 a
(1 row)

ALTER TABLE father_table RENAME TO father_table_new;
SELECT fun7(1) FROM dual;
 fun7 
------
 a
(1 row)

ALTER FUNCTION fun7 COMPILE;
SELECT fun7(1) FROM dual;
 fun7 
------
 a
(1 row)

DROP FUNCTION fun6;
DROP FUNCTION fun7;
DROP TABLE child_table_new;
DROP TABLE father_table_new;
--1.1.5 DROP TABLE [ IF EXISTS ] name [, ...] [ CASCADE | RESTRICT ]
CREATE TABLE t1(id int, name varchar(20));
--function's parameter datatype is tablename.columnname%TYPE
CREATE OR REPLACE FUNCTION fun1(v t1.id%TYPE) RETURN varchar AS
BEGIN
  RETURN v;
END;
/
NOTICE:  type reference t1.id%TYPE converted to pg_catalog.int4
CREATE OR REPLACE PROCEDURE proc1(v t1.id%TYPE) AS
  a varchar(20);
BEGIN
  a := v;
  raise notice '%', a;
END;
/
NOTICE:  type reference t1.id%TYPE converted to pg_catalog.int4
SELECT fun1(1) FROM dual;
 fun1 
------
 1
(1 row)

CALL proc1(1);
NOTICE:  1
DROP TABLE t1;
--after dropping the table t1, failed to call the function again
SELECT fun1(1) FROM dual; --failed
ERROR:  package, relation or view does not exist
CALL proc1(1); --failed
ERROR:  package, relation or view does not exist
ALTER FUNCTION fun1 COMPILE;
WARNING:  compilation error
HINT:  package, relation or view does not exist
ALTER PROCEDURE proc1 COMPILE;
WARNING:  compilation error
HINT:  package, relation or view does not exist
SELECT fun1(1) FROM dual; --failed
ERROR:  function fun1 is in invalid state
CALL proc1(1); --failed
ERROR:  procedure proc1 is in invalid state
DROP FUNCTION fun1;
DROP PROCEDURE proc1;
--function's return datatype is tablename.columnname%TYPE
CREATE TABLE t1(id varchar(20), name varchar(20));
CREATE OR REPLACE FUNCTION fun2(v int) RETURN t1.id%TYPE
AS
BEGIN
  RETURN 'a';
END;
/
NOTICE:  type reference t1.id%TYPE converted to varchar2
SELECT fun2(2) FROM dual;
 fun2 
------
 a
(1 row)

DROP TABLE t1;
--after dropping the table t1, failed to call the function again
SELECT fun2(2) FROM dual; --failed
ERROR:  package, relation or view does not exist
LINE 1: SELECT fun2(2) FROM dual;
               ^
ALTER FUNCTION fun2 COMPILE;
WARNING:  compilation error
HINT:  package, relation or view does not exist
SELECT fun2(2) FROM dual; --failed
ERROR:  package, relation or view does not exist
LINE 1: SELECT fun2(2) FROM dual;
               ^
DROP FUNCTION fun2; 
--Variable datatype is tablename.columnname%TYPE
CREATE TABLE t1(id varchar(20), name varchar(20));
CREATE OR REPLACE FUNCTION fun3(v int) RETURN varchar AS
  a t1.id%TYPE := 'a';
BEGIN
  RETURN a;
END;
/
CREATE OR REPLACE FUNCTION fun4(v int) RETURN varchar AS
  FUNCTION inf1(v1 int) RETURN varchar AS
    a t1.id%TYPE := 'a';
  BEGIN
    RETURN a;
  END;
BEGIN
  RETURN inf1(4);
END;
/
CREATE OR REPLACE FUNCTION fun5(v t1.id%TYPE) RETURN varchar AS
  PROCEDURE inp1(v1 t1.id%TYPE) AS
    a varchar(10);
  BEGIN
    a := v1;
    raise notice '%', a;
  END;
BEGIN
  CALL inp1(v);
  RETURN 'a';
END;
/
NOTICE:  type reference t1.id%TYPE converted to varchar2
SELECT fun3(3) FROM dual;
 fun3 
------
 a
(1 row)

SELECT fun4(4) FROM dual;
 fun4 
------
 a
(1 row)

SELECT fun5(5) FROM dual;
NOTICE:  5
 fun5 
------
 a
(1 row)

DROP TABLE t1;
--after dropping the table t1, call the function again
SELECT fun3(3) FROM dual;  --failed
ERROR:  relation "t1" does not exist
CONTEXT:  compilation of PL/iSQL function "fun3" near line 1
SELECT fun4(4) FROM dual;  --failed
ERROR:  relation "t1" does not exist
CONTEXT:  compilation of PL/iSQL function "fun4" near line 2
SELECT fun5(5) FROM dual;  --failed
ERROR:  package, relation or view does not exist
ALTER FUNCTION fun3 COMPILE;
WARNING:  compilation error
HINT:  relation "t1" does not exist
ALTER FUNCTION fun4 COMPILE;
WARNING:  compilation error
HINT:  relation "t1" does not exist
ALTER FUNCTION fun5 COMPILE;
WARNING:  compilation error
HINT:  package, relation or view does not exist
SELECT fun3(3) FROM dual;  --failed
ERROR:  function fun3 is in invalid state
SELECT fun4(4) FROM dual;  --failed
ERROR:  function fun4 is in invalid state
SELECT fun5(5) FROM dual;  --failed
ERROR:  function fun5 is in invalid state
DROP FUNCTION fun3; 
DROP FUNCTION fun4; 
DROP FUNCTION fun5; 
--use tablename.columnname%TYPE in package
CREATE TABLE t1(id varchar(20), name varchar(20));
CREATE OR REPLACE PACKAGE pkg1 is
  var1 t1.id%TYPE;
  FUNCTION pfun(v int) return varchar;
END;
/
CREATE OR REPLACE PACKAGE BODY pkg1 is
  FUNCTION pfun(v int) RETURN varchar AS
    a t1.id%TYPE := 'a';
  BEGIN
    var1 := 'a';
    a := var1;
    RETURN a;
  END;
END;
/
DECLARE
BEGIN
  raise notice '%', pkg1.pfun(1);
END;
/
NOTICE:  a
DROP TABLE t1;
--after dropping the table t1, failed to call the package function again
DECLARE
BEGIN
  raise notice '%', pkg1.pfun(1);
END;
/
ERROR:  relation "t1" does not exist
CONTEXT:  compilation of PL/iSQL package "pkg1" near line 1
compilation of PL/iSQL function "pkg1" near line 1
DROP PACKAGE pkg1;
--inherit table
CREATE TABLE father_table(c1 integer,c2 varchar(10));
CREATE TABLE child_table(c3 varchar(10)) inherits (father_table);
CREATE OR REPLACE FUNCTION fun6(v int) return varchar as
  a child_table.c3%TYPE := 'a';
BEGIN
  RETURN a;
END;
/
SELECT fun6(1) FROM dual;
 fun6 
------
 a
(1 row)

DROP TABLE child_table;
SELECT fun6(1) FROM dual; --failed
ERROR:  relation "child_table" does not exist
CONTEXT:  compilation of PL/iSQL function "fun6" near line 1
ALTER FUNCTION fun6 COMPILE;
WARNING:  compilation error
HINT:  relation "child_table" does not exist
SELECT fun6(1) FROM dual; --failed
ERROR:  function fun6 is in invalid state
CREATE TABLE child_table(c3 varchar(10)) inherits (father_table);
CREATE OR REPLACE FUNCTION fun7(v int) return varchar as
  a child_table.c2%TYPE := 'a';
BEGIN
  RETURN a;
END;
/
SELECT fun7(1) FROM dual;
 fun7 
------
 a
(1 row)

DROP TABLE father_table cascade;
NOTICE:  drop cascades to table child_table
SELECT fun7(1) FROM dual; --failed
ERROR:  relation "child_table" does not exist
CONTEXT:  compilation of PL/iSQL function "fun7" near line 1
ALTER FUNCTION fun7 COMPILE;
WARNING:  compilation error
HINT:  relation "child_table" does not exist
SELECT fun7(1) FROM dual; --failed
ERROR:  function fun7 is in invalid state
DROP FUNCTION fun6;
DROP FUNCTION fun7;
--1.2 The referencing variable inherits the data type and size of the referenced variable
--the following testcase will fail
DECLARE
  name     VARCHAR(25) NOT NULL := 'Niu';
  surname  name%TYPE := 'abcdefgabcdefgabcdefgabcdefg';
BEGIN
  raise notice 'name=%' ,name;
  raise notice 'surname=%' ,surname;
END;
/
ERROR:  value too long for type varchar2(25 byte)
CONTEXT:  PL/iSQL function inline_code_block line 3 during statement block local variable initialization
--1.3 The referencing variable inherits the Constraints (unless the referenced item is a column) of the referenced variable
--the following testcase will fail
DECLARE
  name     VARCHAR(25) NOT NULL := 'Niu';
  surname  name%TYPE ;
BEGIN
  raise notice 'name=%' ,name;
  raise notice 'surname=%' ,surname;
END;
/
ERROR:  variable "surname" must have a default value, since it's declared NOT NULL
LINE 3:   surname  name%TYPE ;
          ^
QUERY:  DECLARE
  name     VARCHAR(25) NOT NULL := 'Niu';
  surname  name%TYPE ;
BEGIN
  raise notice 'name=%' ,name;
  raise notice 'surname=%' ,surname;
END
CREATE OR REPLACE PROCEDURE proc1(id int)
as
  name     VARCHAR(25) NOT NULL := 'Niu';
  surname  proc1.name%TYPE;
BEGIN
  null;
END;
/
WARNING:  compilation error
HINT:  variable "surname" must have a default value, since it's declared NOT NULL
--successfully
DECLARE
  name     VARCHAR(25) NOT NULL := 'Niu';
  surname  name%TYPE := 'Jones';
BEGIN
  raise notice 'name=%' ,name;
  raise notice 'surname=%' ,surname;
END;
/  
NOTICE:  name=Niu
NOTICE:  surname=Jones
--the referenced item is a column with constraints 
CREATE TABLE t_notnull(id int NOT NULL);
DECLARE
  name     t_notnull.id%TYPE;
BEGIN
  raise notice 'name=%' ,name;
END;
/
NOTICE:  name=<NULL>
DROP TABLE t_notnull;
--already supports cursor_variable%TYPE
CREATE TABLE tp1(unique1 int);
CREATE OR REPLACE PROCEDURE proc1(id int) 
AS
  curs1 CURSOR FOR SELECT * FROM tp1;
  curs2 refcursor;
  curs3 CURSOR (key integer) FOR SELECT * FROM tp1 WHERE unique1 = key;
  curs4 curs1%TYPE;
  curs5 curs2%TYPE;
  curs6 curs3%TYPE;
BEGIN
  OPEN curs1;
  CLOSE curs1;
END;
/	
CALL proc1(1);
DROP TABLE tp1;
DROP PROCEDURE proc1;
--2 %ROWTYPE
--2.1 function's parameter datatype is tablename%ROWTYPE
CREATE OR REPLACE PROCEDURE p0(v employees%ROWTYPE) AS
BEGIN
  raise notice 'v.first_name = %, v.last_name = %, v.phone_number = %',
    v.first_name, v.last_name, v.phone_number;
END;
/
DECLARE
  a employees%ROWTYPE;
BEGIN
  select * into a from employees ;
  raise notice 'a=%', a;
  call p0(a);
END;
/
NOTICE:  a=(Steven,Niu,1-650-555-1234)
NOTICE:  v.first_name = Steven, v.last_name = Niu, v.phone_number = 1-650-555-1234
\df p0
                        List of functions
 Schema | Name | Result data type |  Argument data types   | Type 
--------+------+------------------+------------------------+------
 public | p0   |                  | IN v employees%ROWTYPE | proc
(1 row)

DROP PROCEDURE p0(employees%ROWTYPE);
--2.2 function's return datatype is tablename%ROWTYPE
CREATE OR REPLACE FUNCTION f1(v int) RETURN employees%ROWTYPE AS
  a employees%ROWTYPE;
BEGIN
  select * into a from employees ;
  RETURN a;
END;
/
DECLARE
  res employees%ROWTYPE;
BEGIN
  res := f1(1);
  raise notice 'res.first_name = %, res.last_name = %, res.phone_number = %',
    res.first_name, res.last_name, res.phone_number;
END;
/
NOTICE:  res.first_name = Steven, res.last_name = Niu, res.phone_number = 1-650-555-1234
\df f1
                       List of functions
 Schema | Name | Result data type  | Argument data types | Type 
--------+------+-------------------+---------------------+------
 public | f1   | employees%ROWTYPE | v pg_catalog.int4   | func
(1 row)

DROP FUNCTION f1;
--2.3 subprogram's parameter datatype and return datatype are tablename%ROWTYPE
DECLARE
  a employees%ROWTYPE;
  PROCEDURE p1(v employees%ROWTYPE) AS
  BEGIN
    raise notice 'v.first_name = %, v.last_name = %, v.phone_number = %',
      v.first_name, v.last_name, v.phone_number;
  END;
  FUNCTION f1(v int) RETURN employees%ROWTYPE AS
    a employees%ROWTYPE;
  BEGIN
    select * into a from employees ;
    RETURN a;
  END;
BEGIN
  CALL p1(f1(1));
END;
/
NOTICE:  v.first_name = Steven, v.last_name = Niu, v.phone_number = 1-650-555-1234
--2.4 The referencing variable inherits the data type and size of the referenced variable
CREATE TABLE t1 (
  c1 INTEGER DEFAULT 0 NOT NULL,
  c2 INTEGER DEFAULT 1 NOT NULL
);
 
DECLARE
  t1_row t1%ROWTYPE;
BEGIN
  raise notice 't1_row.c1 = %, t1_row.c2 = %', t1_row.c1, t1_row.c2;
END;
/
NOTICE:  t1_row.c1 = <NULL>, t1_row.c2 = <NULL>
DROP TABLE t1;
--2.5 If the declaration of the referenced item is changed, then the declaration of the referencing item changes accordingly.
--2.5.1 ALTER TABLE [ IF EXISTS ] [ ONLY ] name [ * ] ALTER [ COLUMN ] column_name [ SET DATA ] TYPE data_type [ COLLATE collation ] [ USING expression ]
CREATE TABLE tmpe (first_name varchar(20) not null, 
last_name varchar(20) not null,
phone_number varchar(50));
INSERT INTO tmpe VALUES ('Steven','Niu','1650');
CREATE OR REPLACE PROCEDURE p1(v tmpe%ROWTYPE) AS
  a tmpe.phone_number%TYPE;
BEGIN
  a := 'abc';
END;
/
CREATE OR REPLACE FUNCTION f1(v int) RETURN tmpe%ROWTYPE AS
  a tmpe%ROWTYPE;
BEGIN
  a.phone_number := 'abc';
  RETURN a;
END;
/
CREATE OR REPLACE PACKAGE pkg1 is
  var1 tmpe%ROWTYPE;
  FUNCTION pfun(v tmpe%ROWTYPE) RETURN tmpe%ROWTYPE;
END;
/
CREATE OR REPLACE PACKAGE BODY pkg1 is
  FUNCTION pfun(v tmpe%ROWTYPE) RETURN tmpe%ROWTYPE AS
    r tmpe%ROWTYPE;
  BEGIN
    var1.phone_number := 'abc';
    r.phone_number :=  var1;
    RETURN v;
  END;
END;
/
ALTER TABLE tmpe ALTER COLUMN phone_number TYPE integer using phone_number::integer;
--after changing the column phone_number type from varchar to int, failed to call the function again
DECLARE
  a tmpe%ROWTYPE;
BEGIN
  select * into a from tmpe;
  CALL p1(a);
END;
/
ERROR:  invalid input syntax for type integer: "abc"
LINE 1: a := 'abc'
             ^
QUERY:  a := 'abc'
CONTEXT:  PL/iSQL function p1(tmpe%ROWTYPE) line 3 at assignment
SQL statement "CALL p1(a)"
PL/iSQL function inline_code_block line 5 at CALL
ALTER PROCEDURE p1 COMPILE;
DECLARE
  a tmpe%ROWTYPE;
BEGIN
  select * into a from tmpe;
  CALL p1(a);
END;
/
ERROR:  invalid input syntax for type integer: "abc"
LINE 1: a := 'abc'
             ^
QUERY:  a := 'abc'
CONTEXT:  PL/iSQL function p1(tmpe%ROWTYPE) line 3 at assignment
SQL statement "CALL p1(a)"
PL/iSQL function inline_code_block line 5 at CALL
DECLARE
  res tmpe%ROWTYPE;
BEGIN
  res := f1(1);
  raise notice 'res.first_name = %, res.last_name = %, res.phone_number = %',
    res.first_name, res.last_name, res.phone_number;
END;
/
ERROR:  invalid input syntax for type integer: "abc"
LINE 1: a.phone_number := 'abc'
                          ^
QUERY:  a.phone_number := 'abc'
CONTEXT:  PL/iSQL function f1(pg_catalog.int4) line 3 at assignment
PL/iSQL function inline_code_block line 4 at assignment
DECLARE
BEGIN
  CALL p1(f1(1));
END;
/
ERROR:  invalid input syntax for type integer: "abc"
LINE 1: a.phone_number := 'abc'
                          ^
QUERY:  a.phone_number := 'abc'
CONTEXT:  PL/iSQL function f1(pg_catalog.int4) line 3 at assignment
SQL statement "CALL p1(f1(1))"
PL/iSQL function inline_code_block line 3 at CALL
DECLARE
  a tmpe%ROWTYPE;
BEGIN
  select * into a from tmpe;
  raise notice '%', pkg1.pfun(a);
END;
/
ERROR:  invalid input syntax for type integer: "abc"
LINE 1: var1.phone_number := 'abc'
                             ^
QUERY:  var1.phone_number := 'abc'
CONTEXT:  PL/iSQL function pfun line 4 at assignment
PL/iSQL function inline_code_block line 5 at RAISE
DROP PROCEDURE p1(v tmpe%ROWTYPE);
DROP FUNCTION f1(v int);
DROP PACKAGE pkg1;
DROP TABLE tmpe CASCADE;
--2.5.2 ALTER TABLE [ IF EXISTS ] [ ONLY ] name [ * ] DROP [ COLUMN ] [ IF EXISTS ] column_name [ RESTRICT | CASCADE ]
CREATE TABLE tmpe (first_name varchar(20) not null, 
last_name varchar(20) not null,
phone_number varchar(50));
INSERT INTO tmpe VALUES ('Steven','Niu','1650');
CREATE OR REPLACE PROCEDURE p1(v tmpe%ROWTYPE) AS
BEGIN
  raise notice 'v.first_name = %, v.last_name = %, v.phone_number = %',
    v.first_name, v.last_name, v.phone_number;
END;
/
CREATE OR REPLACE FUNCTION f1(v int) RETURN tmpe%ROWTYPE AS
  a tmpe%ROWTYPE;
BEGIN
  select * into a from tmpe;
  raise notice 'a.first_name = %, a.last_name = %, a.phone_number = %',
    a.first_name, a.last_name, a.phone_number; 
  RETURN a;
END;
/
CREATE OR REPLACE FUNCTION f2(v int) RETURN varchar AS
  a tmpe%ROWTYPE;
BEGIN
  RETURN a.phone_number;
END;
/
CREATE OR REPLACE FUNCTION f3(v int) RETURN varchar AS
  a tmpe%ROWTYPE;
  r varchar(20);
BEGIN
  r := a.phone_number;
  RETURN r;
END;
/
CREATE OR REPLACE PACKAGE pkg1 is
  var1 tmpe%ROWTYPE;
  FUNCTION pfun(v tmpe%ROWTYPE) RETURN tmpe%ROWTYPE;
END;
/
CREATE OR REPLACE PACKAGE BODY pkg1 is
  FUNCTION pfun(v tmpe%ROWTYPE) RETURN tmpe%ROWTYPE AS
    r tmpe%ROWTYPE;
  BEGIN
    r.phone_number :=  'abc';
    RETURN v;
  END;
END;
/
ALTER TABLE tmpe DROP COLUMN phone_number;
--after dropping the column phone_number, failed to call the function and procedure again
DECLARE
  a tmpe%ROWTYPE;
BEGIN
  select * into a from tmpe;
  CALL p1(a);
END;
/
ERROR:  record "v" has no field "phone_number"
CONTEXT:  SQL expression "v.phone_number"
PL/iSQL function p1(tmpe%ROWTYPE) line 2 at RAISE
SQL statement "CALL p1(a)"
PL/iSQL function inline_code_block line 5 at CALL
DECLARE
  res tmpe%ROWTYPE;
BEGIN
  res := f1(1);
  raise notice 'res.first_name = %, res.last_name = %, res.phone_number = %',
    res.first_name, res.last_name, res.phone_number;
END;
/
ERROR:  record "a" has no field "phone_number"
CONTEXT:  SQL expression "a.phone_number"
PL/iSQL function f1(pg_catalog.int4) line 4 at RAISE
PL/iSQL function inline_code_block line 4 at assignment
DECLARE
BEGIN
  CALL p1(f1(1));
END;
/
ERROR:  record "a" has no field "phone_number"
CONTEXT:  SQL expression "a.phone_number"
PL/iSQL function f1(pg_catalog.int4) line 4 at RAISE
SQL statement "CALL p1(f1(1))"
PL/iSQL function inline_code_block line 3 at CALL
DECLARE
  res varchar(20);
BEGIN
  res := f2(1);
  raise notice 'res = %', res;
END;
/
ERROR:  record "a" has no field "phone_number"
CONTEXT:  SQL expression "a.phone_number"
PL/iSQL function f2(pg_catalog.int4) line 3 at RETURN
PL/iSQL function inline_code_block line 4 at assignment
DECLARE
  res varchar(20);
BEGIN
  res := f3(1);
  raise notice 'res = %', res;
END;
/
ERROR:  record "a" has no field "phone_number"
CONTEXT:  PL/iSQL assignment "r := a.phone_number"
PL/iSQL function f3(pg_catalog.int4) line 4 at assignment
PL/iSQL function inline_code_block line 4 at assignment
DECLARE
  a tmpe%ROWTYPE;
BEGIN
  select * into a from tmpe;
  raise notice '%', pkg1.pfun(a);
END;
/
ERROR:  record "r" has no field "phone_number"
CONTEXT:  PL/iSQL assignment "r.phone_number :=  'abc'"
PL/iSQL function pfun line 4 at assignment
PL/iSQL function inline_code_block line 5 at RAISE
DROP PROCEDURE p1(v tmpe%ROWTYPE);
DROP FUNCTION f1(v int);
DROP FUNCTION f2(v int);
DROP FUNCTION f3(v int);
DROP PACKAGE pkg1;
DROP TABLE tmpe CASCADE;
--2.5.3 ALTER TABLE [ IF EXISTS ] [ ONLY ] name [ * ] RENAME [ COLUMN ] column_name TO new_column_name
CREATE TABLE tmpe (first_name varchar(20) not null, 
last_name varchar(20) not null,
phone_number varchar(50));
INSERT INTO tmpe VALUES ('Steven','Niu','1650');
CREATE OR REPLACE PROCEDURE p1(v tmpe%ROWTYPE) AS
BEGIN
  raise notice 'v.first_name = %, v.last_name = %, v.phone_number = %',
    v.first_name, v.last_name, v.phone_number;
END;
/
CREATE OR REPLACE FUNCTION f1(v int) RETURN tmpe%ROWTYPE AS
  a tmpe%ROWTYPE;
BEGIN
  select * into a from tmpe;
  raise notice 'a.first_name = %, a.last_name = %, a.phone_number = %',
    a.first_name, a.last_name, a.phone_number; 
  RETURN a;
END;
/
CREATE OR REPLACE FUNCTION f2(v int) RETURN varchar AS
  a tmpe%ROWTYPE;
BEGIN
  RETURN a.phone_number;
END;
/
CREATE OR REPLACE FUNCTION f3(v int) RETURN varchar AS
  a tmpe%ROWTYPE;
  r varchar(20);
BEGIN
  r := a.phone_number;
  RETURN r;
END;
/
CREATE OR REPLACE PACKAGE pkg1 is
  var1 tmpe%ROWTYPE;
  FUNCTION pfun(v tmpe%ROWTYPE) RETURN tmpe%ROWTYPE;
END;
/
CREATE OR REPLACE PACKAGE BODY pkg1 is
  FUNCTION pfun(v tmpe%ROWTYPE) RETURN tmpe%ROWTYPE AS
    r tmpe%ROWTYPE;
  BEGIN
    r.phone_number :=  'abc';
    RETURN v;
  END;
END;
/
ALTER TABLE tmpe RENAME COLUMN phone_number TO phone;
--after renaming the column phone_number to phone, failed to call the function 
DECLARE
  a tmpe%ROWTYPE;
BEGIN
  select * into a from tmpe;
  CALL p1(a);
END;
/
ERROR:  record "v" has no field "phone_number"
CONTEXT:  SQL expression "v.phone_number"
PL/iSQL function p1(tmpe%ROWTYPE) line 2 at RAISE
SQL statement "CALL p1(a)"
PL/iSQL function inline_code_block line 5 at CALL
DECLARE
  res tmpe%ROWTYPE;
BEGIN
  res := f1(1);
  raise notice 'res.first_name = %, res.last_name = %, res.phone_number = %',
    res.first_name, res.last_name, res.phone_number;
END;
/
ERROR:  record "a" has no field "phone_number"
CONTEXT:  SQL expression "a.phone_number"
PL/iSQL function f1(pg_catalog.int4) line 4 at RAISE
PL/iSQL function inline_code_block line 4 at assignment
DECLARE
BEGIN
  CALL p1(f1(1));
END;
/
ERROR:  record "a" has no field "phone_number"
CONTEXT:  SQL expression "a.phone_number"
PL/iSQL function f1(pg_catalog.int4) line 4 at RAISE
SQL statement "CALL p1(f1(1))"
PL/iSQL function inline_code_block line 3 at CALL
DECLARE
  res varchar(20);
BEGIN
  res := f2(1);
  raise notice 'res = %', res;
END;
/
ERROR:  record "a" has no field "phone_number"
CONTEXT:  SQL expression "a.phone_number"
PL/iSQL function f2(pg_catalog.int4) line 3 at RETURN
PL/iSQL function inline_code_block line 4 at assignment
DECLARE
  res varchar(20);
BEGIN
  res := f3(1);
  raise notice 'res = %', res;
END;
/
ERROR:  record "a" has no field "phone_number"
CONTEXT:  PL/iSQL assignment "r := a.phone_number"
PL/iSQL function f3(pg_catalog.int4) line 4 at assignment
PL/iSQL function inline_code_block line 4 at assignment
DECLARE
  a tmpe%ROWTYPE;
BEGIN
  select * into a from tmpe;
  raise notice '%', pkg1.pfun(a);
END;
/
ERROR:  record "r" has no field "phone_number"
CONTEXT:  PL/iSQL assignment "r.phone_number :=  'abc'"
PL/iSQL function pfun line 4 at assignment
PL/iSQL function inline_code_block line 5 at RAISE
DROP PROCEDURE p1(v tmpe%ROWTYPE);
DROP FUNCTION f1(v int);
DROP FUNCTION f2(v int);
DROP FUNCTION f3(v int);
DROP PACKAGE pkg1;
DROP TABLE tmpe CASCADE;
--2.5.4 ALTER TABLE [ IF EXISTS ] name  RENAME TO new_name
CREATE TABLE tmpe (first_name varchar(20) not null, 
last_name varchar(20) not null,
phone_number varchar(50));
INSERT INTO tmpe VALUES ('Steven','Niu','1650');
CREATE OR REPLACE PROCEDURE p1(v tmpe%ROWTYPE) AS
BEGIN
  raise notice 'v.first_name = %, v.last_name = %, v.phone_number = %',
    v.first_name, v.last_name, v.phone_number;
END;
/
CREATE OR REPLACE FUNCTION f1(v int) RETURN tmpe%ROWTYPE AS
  a tmpe%ROWTYPE;
BEGIN
  select * into a from tmpe;
  raise notice 'a.first_name = %, a.last_name = %, a.phone_number = %',
    a.first_name, a.last_name, a.phone_number; 
  RETURN a;
END;
/
CREATE OR REPLACE FUNCTION f2(v int) RETURN varchar AS
  a tmpe%ROWTYPE;
BEGIN
  RETURN a.phone_number;
END;
/
CREATE OR REPLACE FUNCTION f3(v int) RETURN varchar AS
  a tmpe%ROWTYPE;
  r varchar(20);
BEGIN
  r := a.phone_number;
  RETURN r;
END;
/
CREATE OR REPLACE PACKAGE pkg1 is
  var1 tmpe%ROWTYPE;
  FUNCTION pfun(v tmpe%ROWTYPE) RETURN tmpe%ROWTYPE;
END;
/
CREATE OR REPLACE PACKAGE BODY pkg1 is
  FUNCTION pfun(v tmpe%ROWTYPE) RETURN tmpe%ROWTYPE AS
    r tmpe%ROWTYPE;
  BEGIN
    r.phone_number :=  'abc';
    RETURN v;
  END;
END;
/
ALTER TABLE tmpe RENAME TO tmpe2;
--after renaming the table tmpe to tmpe2, failed to call the function and procedure again
DECLARE
  a tmpe2%ROWTYPE;
BEGIN
  select * into a from tmpe2;
  CALL p1(a);
END;
/
ERROR:  package, relation or view does not exist
CONTEXT:  SQL statement "CALL p1(a)"
PL/iSQL function inline_code_block line 5 at CALL
DECLARE
  res tmpe2%ROWTYPE;
BEGIN
  res := f1(1);
  raise notice 'res.first_name = %, res.last_name = %, res.phone_number = %',
    res.first_name, res.last_name, res.phone_number;
END;
/
ERROR:  package, relation or view does not exist
LINE 1: res := f1(1)
               ^
QUERY:  res := f1(1)
CONTEXT:  PL/iSQL function inline_code_block line 4 at assignment
DECLARE
BEGIN
  CALL p1(f1(1));
END;
/
ERROR:  package, relation or view does not exist
LINE 1: CALL p1(f1(1))
                ^
QUERY:  CALL p1(f1(1))
CONTEXT:  PL/iSQL function inline_code_block line 3 at CALL
DECLARE
  res varchar(20);
BEGIN
  res := f2(1);
  raise notice 'res = %', res;
END;
/
ERROR:  relation "tmpe" does not exist
CONTEXT:  compilation of PL/iSQL function "f2" near line 1
PL/iSQL function inline_code_block line 4 at assignment
DECLARE
  res varchar(20);
BEGIN
  res := f3(1);
  raise notice 'res = %', res;
END;
/
ERROR:  relation "tmpe" does not exist
CONTEXT:  compilation of PL/iSQL function "f3" near line 1
PL/iSQL function inline_code_block line 4 at assignment
DECLARE
  a tmpe2%ROWTYPE;
BEGIN
  select * into a from tmpe2;
  raise notice '%', pkg1.pfun(a);
END;
/
ERROR:  relation "tmpe" does not exist
CONTEXT:  compilation of PL/iSQL package "pkg1" near line 1
compilation of PL/iSQL function "pkg1" near line 1
DROP PROCEDURE p1(v tmpe2%ROWTYPE);
DROP FUNCTION f1(v int);
DROP FUNCTION f2(v int);
DROP FUNCTION f3(v int);
DROP PACKAGE pkg1;
DROP TABLE tmpe2 CASCADE;
--2.5.5 DROP TABLE [ IF EXISTS ] name [, ...] [ CASCADE | RESTRICT ]
CREATE TABLE tmpe (first_name varchar(20) not null, 
  last_name varchar(20) not null,
  phone_number varchar(50));
INSERT INTO tmpe VALUES ('Steven','Niu','1650');
CREATE OR REPLACE PROCEDURE p1(v tmpe%ROWTYPE) AS
BEGIN
  raise notice 'v.first_name = %, v.last_name = %, v.phone_number = %',
    v.first_name, v.last_name, v.phone_number;
END;
/
CREATE OR REPLACE FUNCTION f1(v int) RETURN tmpe%ROWTYPE AS
  a tmpe%ROWTYPE;
BEGIN
  select * into a from tmpe;
  raise notice 'a.first_name = %, a.last_name = %, a.phone_number = %',
    a.first_name, a.last_name, a.phone_number; 
  RETURN a;
END;
/
CREATE OR REPLACE FUNCTION f2(v int) RETURN varchar AS
  a tmpe%ROWTYPE;
BEGIN
  RETURN a.phone_number;
END;
/
CREATE OR REPLACE FUNCTION f3(v int) RETURN varchar AS
  a tmpe%ROWTYPE;
  r varchar(20);
BEGIN
  r := a.phone_number;
  RETURN r;
END;
/
CREATE OR REPLACE PACKAGE pkg1 is
  var1 tmpe%ROWTYPE;
  FUNCTION pfun(v tmpe%ROWTYPE) RETURN tmpe%ROWTYPE;
END;
/
CREATE OR REPLACE PACKAGE BODY pkg1 is
  FUNCTION pfun(v tmpe%ROWTYPE) RETURN tmpe%ROWTYPE AS
    r tmpe%ROWTYPE;
  BEGIN
    r.phone_number :=  'abc';
    RETURN v;
  END;
END;
/
DROP TABLE tmpe;
--after dropping the table tmpe, failed to call the function and procedure
DECLARE
  a tmpe%ROWTYPE;
BEGIN
  select * into a from tmpe;
  CALL p1(a);
END;
/
ERROR:  relation "tmpe" does not exist
CONTEXT:  compilation of PL/iSQL function "inline_code_block" near line 2
DECLARE
  res tmpe%ROWTYPE;
BEGIN
  res := f1(1);
  raise notice 'res.first_name = %, res.last_name = %, res.phone_number = %',
    res.first_name, res.last_name, res.phone_number;
END;
/
ERROR:  relation "tmpe" does not exist
CONTEXT:  compilation of PL/iSQL function "inline_code_block" near line 2
DECLARE
BEGIN
  CALL p1(f1(1));
END;
/
ERROR:  package, relation or view does not exist
LINE 1: CALL p1(f1(1))
                ^
QUERY:  CALL p1(f1(1))
CONTEXT:  PL/iSQL function inline_code_block line 3 at CALL
DECLARE
  res varchar(20);
BEGIN
  res := f2(1);
  raise notice 'res = %', res;
END;
/
ERROR:  relation "tmpe" does not exist
CONTEXT:  compilation of PL/iSQL function "f2" near line 1
PL/iSQL function inline_code_block line 4 at assignment
DECLARE
  res varchar(20);
BEGIN
  res := f3(1);
  raise notice 'res = %', res;
END;
/
ERROR:  relation "tmpe" does not exist
CONTEXT:  compilation of PL/iSQL function "f3" near line 1
PL/iSQL function inline_code_block line 4 at assignment
DECLARE
  a tmpe%ROWTYPE;
BEGIN
  select * into a from tmpe;
  raise notice '%', pkg1.pfun(a);
END;
/
ERROR:  relation "tmpe" does not exist
CONTEXT:  compilation of PL/iSQL function "inline_code_block" near line 2
DROP PROCEDURE p1;
DROP FUNCTION f1(v int);
DROP FUNCTION f2(v int);
DROP FUNCTION f3(v int);
DROP PACKAGE pkg1;
--3 INSERT INTO table_name VALUES var
CREATE TABLE t1(id int, name varchar(20));
--Record that variables are allowed in the VALUES clause of an INSERT statement
DECLARE
  v1 t1%ROWTYPE;
BEGIN
  FOR i IN 1 .. 5 LOOP
    v1.id := i;
	v1.name := 'a' || i;
    INSERT INTO t1 VALUES v1;
  END LOOP;
END;
/
SELECT * FROM t1;
 id | name 
----+------
  1 | a1
  2 | a2
  3 | a3
  4 | a4
  5 | a5
(5 rows)

--Record that variables are allowed in the INTO subclause of a RETURNING clause
DECLARE
  v1 t1%ROWTYPE;
  v2 t1%ROWTYPE;
BEGIN
  v1.id := 6; 
  v1.name := 'a6';
  INSERT INTO t1 VALUES v1 returning id,name into v2;
  raise notice 'v2 = %', v2;
END;
/
NOTICE:  v2 = (6,a6)
SELECT * FROM t1;
 id | name 
----+------
  1 | a1
  2 | a2
  3 | a3
  4 | a4
  5 | a5
  6 | a6
(6 rows)

--test subprograms
DELETE FROM t1;
DECLARE
  FUNCTION f1(a int) RETURN INT AS
    v1 t1%ROWTYPE;
  BEGIN
    v1.id := 7; 
    v1.name := 'a7';
    INSERT INTO t1 VALUES v1;
	return 1;
  END;
BEGIN
  perform f1(1);
END;
/
SELECT * FROM t1;
 id | name 
----+------
  7 | a7
(1 row)

--test package
CREATE OR REPLACE PACKAGE pkg1 is
  FUNCTION pfun(v int) return varchar;
END;
/
CREATE OR REPLACE PACKAGE BODY pkg1 is
  FUNCTION pfun(v int) RETURN varchar AS
    v1 t1%ROWTYPE;
  BEGIN
    v1.id := 8; 
    v1.name := 'efg';
    INSERT INTO t1 VALUES v1;
    RETURN v1.name;
  END;
END;
/
DECLARE
BEGIN
  raise notice '%', pkg1.pfun(1);
END;
/
NOTICE:  efg
SELECT * FROM t1;
 id | name 
----+------
  7 | a7
  8 | efg
(2 rows)

DROP PACKAGE pkg1;
--INSERT INTO tablename VALUES row_variable 
CREATE TABLE t2(id int, name varchar(20));
DELETE FROM t1;
DECLARE
  v1 t2%ROWTYPE;
BEGIN
  v1.id := 9; 
  v1.name := 'abc9';
  INSERT INTO t1 VALUES v1;
END;
/
SELECT * FROM t1;
 id | name 
----+------
  9 | abc9
(1 row)

DROP TABLE t2;
--nested rowtype
CREATE TABLE tn1(id int, name varchar(20));
CREATE TABLE tn2(c1 t1);
DECLARE
  v1 tn2%ROWTYPE;
BEGIN
  v1.c1.id := 10; 
  v1.c1.name := 'abc10';
  INSERT INTO tn2 VALUES v1;
END;
/
SELECT * FROM tn2;
     c1     
------------
 (10,abc10)
(1 row)

DECLARE
  v1 tn2%ROWTYPE;
BEGIN
  v1.c1.id := 11; 
  v1.c1.name := 'abcd11';
  INSERT INTO tn1 VALUES v1.c1;
END;
/
SELECT * FROM tn1;
 id |  name  
----+--------
 11 | abcd11
(1 row)

DROP TABLE tn2;
DROP TABLE tn1;
--%ROWTYPE Attribute and Virtual Columns
CREATE TABLE plch_departure (
  destination    VARCHAR2(100),
  departure_time DATE,
  delay          NUMBER(10),
  expected       DATE GENERATED ALWAYS AS (departure_time + delay/24/60/60) STORED
);
DECLARE
 dep_rec plch_departure%ROWTYPE;
BEGIN
  dep_rec.destination := 'X'; 
  dep_rec.departure_time := TO_DATE('2023-2-12');
  dep_rec.delay := 1500;
  INSERT INTO plch_departure VALUES dep_rec;
END;
/
ERROR:  cannot insert a non-DEFAULT value into column "expected"
DETAIL:  Column "expected" is a generated column.
CONTEXT:  SQL statement "INSERT INTO plch_departure VALUES dep_rec"
PL/iSQL function inline_code_block line 7 at SQL statement
--insert the individual record fields into the table, excluding the virtual column.
DECLARE
  dep_rec plch_departure%rowtype;
BEGIN
  dep_rec.destination := 'X';
  dep_rec.departure_time := TO_DATE('2023-2-12');
  dep_rec.delay := 1500;
 
  INSERT INTO plch_departure (destination, departure_time, delay)
  VALUES (dep_rec.destination, dep_rec.departure_time, dep_rec.delay);
end;
/
SELECT * FROM plch_departure;
 destination | departure_time | delay |  expected  
-------------+----------------+-------+------------
 X           | 2023-02-12     | 1500  | 2023-02-12
(1 row)

DROP TABLE plch_departure;
--rainy-day test cases of the INSERT statment
--If the VALUES clause of an INSERT statement contains a record variable, no other variable or value is allowed in the clause.
DECLARE
  v1 t1%ROWTYPE;
BEGIN
  v1.id := 11; 
  v1.name := 'abc';
  INSERT INTO t1 VALUES v1, v1;
END;
/
ERROR:  syntax error at or near ","
LINE 6:   INSERT INTO t1 VALUES v1, v1;
                                  ^
QUERY:  DECLARE
  v1 t1%ROWTYPE;
BEGIN
  v1.id := 11; 
  v1.name := 'abc';
  INSERT INTO t1 VALUES v1, v1;
END
--If the INTO subclause of a RETURNING clause contains a record variable, no other variable or value is allowed in the subclause.
DECLARE
  v1 t1%ROWTYPE;
  v2 t1%ROWTYPE;
BEGIN
  v1.id := 12; 
  v1.name := 'abcd';
  INSERT INTO t1 VALUES v1 returning id,name into v2,v2;
END;
/
ERROR:  record variable cannot be part of multiple-item INTO list
LINE 7:   INSERT INTO t1 VALUES v1 returning id,name into v2,v2;
                                                            ^
QUERY:  DECLARE
  v1 t1%ROWTYPE;
  v2 t1%ROWTYPE;
BEGIN
  v1.id := 12; 
  v1.name := 'abcd';
  INSERT INTO t1 VALUES v1 returning id,name into v2,v2;
END
DECLARE
  v1 t1%ROWTYPE;
BEGIN
  v1.id := 11; 
  v1.name := 'abc';
  INSERT INTO t1 VALUES v1.*;
END;
/
ERROR:  invalid user.table.column, table.column, or column specification
LINE 1: INSERT INTO t1 VALUES v1.*
                              ^
QUERY:  INSERT INTO t1 VALUES v1.*
CONTEXT:  PL/iSQL function inline_code_block line 6 at SQL statement
DECLARE
  v1 t1%ROWTYPE;
BEGIN
  v1.id := 11; 
  v1.name := 'abc';
  INSERT INTO t1 VALUES v1 where v1.id > 1;
END;
/
ERROR:  syntax error at or near "where"
LINE 6:   INSERT INTO t1 VALUES v1 where v1.id > 1;
                                   ^
QUERY:  DECLARE
  v1 t1%ROWTYPE;
BEGIN
  v1.id := 11; 
  v1.name := 'abc';
  INSERT INTO t1 VALUES v1 where v1.id > 1;
END
CREATE OR REPLACE FUNCTION f1(v int) RETURN t1%ROWTYPE AS
  a t1%ROWTYPE;
BEGIN
  select * into a from t1;
  RETURN a;
END;
/
--INSERT INTO tablename VALUES func, failed to execute the statement
declare
  r  t1%ROWTYPE;
begin
  insert into t1 values f1(1);
end;
/
ERROR:  syntax error at or near "("
LINE 4:   insert into t1 values f1(1);
                                  ^
QUERY:  declare
  r  t1%ROWTYPE;
begin
  insert into t1 values f1(1);
end
--INSERT INTO tablename VALUES row_variable, succeeded to execute the statement
declare
  r  t1%ROWTYPE;
begin
  r :=  f1(1);
  insert into t1 values r;
end;
/
DROP FUNCTION f1(int);
--not support record inserts using the EXECUTE statement.
declare
  r  t1%ROWTYPE;
begin
  r.id := 11; 
  r.name := 'abc';
  execute 'insert into t1 values :1' using r;
end;
/
ERROR:  syntax error at or near ":1"
LINE 1: insert into t1 values :1
                              ^
QUERY:  insert into t1 values :1
CONTEXT:  PL/iSQL function inline_code_block line 6 at EXECUTE
--INSERT INTO tablename VALUES row_variable which fields are not matched with tablename 
CREATE TABLE t3(id int);
CREATE TABLE t4(id int, name varchar(20), id2 int);
CREATE TABLE t5(id varchar(20), name varchar(20));
DECLARE
  v1 t3%ROWTYPE;
BEGIN
  v1.id := 11;
  INSERT INTO t1 VALUES v1;
END;
/
ERROR:  no enough values
CONTEXT:  SQL statement "INSERT INTO t1 VALUES v1"
PL/iSQL function inline_code_block line 5 at SQL statement
DECLARE
  v1 t4%ROWTYPE;
BEGIN
  v1.id := 11;
  v1.name := 'a';
  v1.id2 := 12;
  INSERT INTO t1 VALUES v1;
END;
/
ERROR:  too many values
CONTEXT:  SQL statement "INSERT INTO t1 VALUES v1"
PL/iSQL function inline_code_block line 7 at SQL statement
DECLARE
  v1 t5%ROWTYPE;
BEGIN
  v1.id := 'a';
  v1.name := 'a';
  INSERT INTO t1 VALUES v1;
END;
/
ERROR:  column "id" is of type pg_catalog.int4 but expression is of type varchar2
LINE 1: INSERT INTO t1 VALUES v1
                              ^
HINT:  You will need to rewrite or cast the expression.
QUERY:  INSERT INTO t1 VALUES v1
CONTEXT:  PL/iSQL function inline_code_block line 6 at SQL statement
DROP TABLE t3;
DROP TABLE t4;
DROP TABLE t5;
--a column has a NOT NULL constraint, then the corresponding field of rowtype cannot have a NULL value.
CREATE TABLE t6(id int NOT NULL, name varchar(20));
DECLARE
  v1 t6%ROWTYPE;
BEGIN
  v1.name := 'a';
  INSERT INTO t6 VALUES v1;
END;
/
ERROR:  null value in column "id" of relation "t6" violates not-null constraint
DETAIL:  Failing row contains (null, a).
CONTEXT:  SQL statement "INSERT INTO t6 VALUES v1"
PL/iSQL function inline_code_block line 5 at SQL statement
DROP TABLE t6;
--4 UPDATE table_name SET ROW = var [WHERE...]
DELETE FROM t1;
DECLARE
  v1 t1%ROWTYPE;
  v2 t1%ROWTYPE;
BEGIN
  v1.id := 11; 
  v1.name := 'abc';
  INSERT INTO t1 VALUES v1;
  v2.id := 22;
  v2.name := 'new';
  UPDATE t1 SET ROW = v2;
END;
/
SELECT * FROM t1;
 id | name 
----+------
 22 | new
(1 row)

DECLARE
  v2 t1%ROWTYPE;
BEGIN
  v2.id := 33;
  v2.name := 'new3';
  UPDATE t1 AS t SET ROW = v2;
END;
/
SELECT * FROM t1;
 id | name 
----+------
 33 | new3
(1 row)

--where clause
INSERT INTO t1 VALUES(1, 'a');
SELECT * FROM t1;
 id | name 
----+------
 33 | new3
  1 | a
(2 rows)

DECLARE
  v2 t1%ROWTYPE;
BEGIN
  v2.id := 44;
  v2.name := 'new4';
  UPDATE t1 AS t SET ROW = v2 where id = 33;
END;
/
SELECT * FROM t1;
 id | name 
----+------
  1 | a
 44 | new4
(2 rows)

--Record variables are allowed in the INTO subclause of a RETURNING clause
DELETE FROM t1;
INSERT INTO t1 VALUES(1, 'a');
DECLARE
  v1 t1%ROWTYPE;
  v2 t1%ROWTYPE;
BEGIN
  v2.id := 55;
  v2.name := 'new5';
  UPDATE t1 AS t SET ROW = v2 RETURNING id, name into v1;
  raise notice 'v1 = %', v1;
END;
/
NOTICE:  v1 = (55,new5)
SELECT * FROM t1;
 id | name 
----+------
 55 | new5
(1 row)

--rainy-day test cases of the UPDATE statment
--cannot set ROW with a subquery
CREATE TABLE t0(id int);
INSERT INTO t0 VALUES(1);
DECLARE
  v2 t0%ROWTYPE;
BEGIN
  v2.id := 66;
  UPDATE t0 AS t SET ROW = (select id from t0 where id = 55);
END;
/
ERROR:  type pg_catalog.int4 is not composite
CONTEXT:  SQL statement "UPDATE t0 AS t SET ROW = (select id from t0 where id = 55)"
PL/iSQL function inline_code_block line 5 at SQL statement
DROP TABLE t0;
DECLARE
  v2 t1%ROWTYPE;
BEGIN
  v2.id := 66;
  v2.name := 'new6';
  UPDATE t1 AS t SET ROW = repeat('x', 10000) WHERE  id = 33;
END;
/
ERROR:  unsupported target
LINE 1: UPDATE t1 AS t SET ROW = repeat('x', 10000) WHERE  id = 33
                           ^
QUERY:  UPDATE t1 AS t SET ROW = repeat('x', 10000) WHERE  id = 33
CONTEXT:  PL/iSQL function inline_code_block line 6 at SQL statement
DECLARE
  v2 t1%ROWTYPE;
BEGIN
  v2.id := 66;
  v2.name := 'new6';
  UPDATE t1 AS t SET ROW = v2, id = 1;
END;
/
ERROR:  too many values
LINE 1: UPDATE t1 AS t SET ROW = v2, id = 1
                           ^
QUERY:  UPDATE t1 AS t SET ROW = v2, id = 1
CONTEXT:  PL/iSQL function inline_code_block line 6 at SQL statement
--In an UPDATE statement, only one SET clause is allowed if ROW is used
DECLARE
  v2 t1%ROWTYPE;
BEGIN
  v2.id := 66;
  v2.name := 'new6';
  UPDATE t1 AS t SET ROW = v2, ROW = v2;
END;
/
ERROR:  too many values
LINE 1: UPDATE t1 AS t SET ROW = v2, ROW = v2
                           ^
QUERY:  UPDATE t1 AS t SET ROW = v2, ROW = v2
CONTEXT:  PL/iSQL function inline_code_block line 6 at SQL statement
--If the INTO subclause of a RETURNING clause contains a record variable, no other variable or value is allowed in the subclause.
DECLARE
  v1 t1%ROWTYPE;
  v2 t1%ROWTYPE;
  v3 int;
BEGIN
  v2.id := 66;
  v2.name := 'new6';
  UPDATE t1 AS t SET ROW = v2 RETURNING id, name,id into v1, v3;
END;
/
ERROR:  record variable cannot be part of multiple-item INTO list
LINE 8: ...DATE t1 AS t SET ROW = v2 RETURNING id, name,id into v1, v3;
                                                                  ^
QUERY:  DECLARE
  v1 t1%ROWTYPE;
  v2 t1%ROWTYPE;
  v3 int;
BEGIN
  v2.id := 66;
  v2.name := 'new6';
  UPDATE t1 AS t SET ROW = v2 RETURNING id, name,id into v1, v3;
END
--not support functions that return a %ROWTYPE type
CREATE OR REPLACE FUNCTION f2(v int) RETURN t1%ROWTYPE AS
  a t1%ROWTYPE;
BEGIN
  select * into a from t1;
  RETURN a;
END;
/
declare
  r  t1%ROWTYPE;
begin
  UPDATE t1 AS t SET ROW = f2(1);
end;
/
ERROR:  unsupported target
LINE 1: UPDATE t1 AS t SET ROW = f2(1)
                           ^
QUERY:  UPDATE t1 AS t SET ROW = f2(1)
CONTEXT:  PL/iSQL function inline_code_block line 4 at SQL statement
DROP FUNCTION f2(int);
--not support record updates using the EXECUTE statement.
declare
  r  t1%ROWTYPE;
begin
  execute 'UPDATE t1 AS t SET ROW = :1' using r;
end;
/
ERROR:  unsupported target
LINE 1: UPDATE t1 AS t SET ROW = :1
                           ^
QUERY:  UPDATE t1 AS t SET ROW = :1
CONTEXT:  PL/iSQL function inline_code_block line 4 at EXECUTE
--5 prostatus in pg_proc catalog
--5.1 set check_function_bodies = on
--5.1.1 simple test
set check_function_bodies = on;
DROP TABLE t1;
CREATE TABLE t1(id varchar(20), name varchar(20));
CREATE OR REPLACE FUNCTION fun5(v int) RETURN t1.id%TYPE AS
BEGIN
  RETURN v;
END;
/
NOTICE:  type reference t1.id%TYPE converted to varchar2
SELECT prostatus FROM pg_proc WHERE proname like 'fun5'; --v
 prostatus 
-----------
 v
(1 row)

SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE c.relname like 't1'
  AND d.refobjid = c.oid
  AND d.objid = p.oid
  AND p.proname like 'fun5';  --1
 count 
-------
     1
(1 row)

CREATE OR REPLACE FUNCTION fun6(v int) RETURN int AS
  a t1.id%TYPE;
  b t1.id%TYPE;
BEGIN
  RETURN v;
END;
/
SELECT prostatus FROM pg_proc WHERE proname like 'fun6';  --v
 prostatus 
-----------
 v
(1 row)

SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE c.relname like 't1'
  AND d.refobjid = c.oid
  AND d.objid = p.oid
  AND p.proname like 'fun6'; --1
 count 
-------
     1
(1 row)

CREATE OR REPLACE FUNCTION fun7(v t1.id%TYPE, v1 t1.name%TYPE) RETURN t1.id%TYPE AS
  a t1.id%TYPE;
  b t1.name%TYPE;
BEGIN
  RETURN v;
END;
/
NOTICE:  type reference t1.id%TYPE converted to varchar2
NOTICE:  type reference t1.name%TYPE converted to varchar2
NOTICE:  type reference t1.id%TYPE converted to varchar2
SELECT prostatus FROM pg_proc WHERE proname like 'fun7'; --v
 prostatus 
-----------
 v
(1 row)

SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE c.relname like 't1'
  AND d.refobjid = c.oid
  AND d.objid = p.oid
  AND p.proname like 'fun7'; --2
 count 
-------
     2
(1 row)

CREATE OR REPLACE FUNCTION fun8(v t1%ROWTYPE, v1 t1%ROWTYPE) RETURN t1%ROWTYPE AS
BEGIN
  RETURN v;
END;
/
SELECT prostatus FROM pg_proc WHERE proname like 'fun8'; --v
 prostatus 
-----------
 v
(1 row)

SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE c.relname like 't1'
  AND d.refobjid = c.oid
  AND d.objid = p.oid
  AND p.proname like 'fun8'; --1
 count 
-------
     1
(1 row)

CREATE OR REPLACE FUNCTION fun9() RETURN t1%ROWTYPE AS
  a t1%ROWTYPE;
BEGIN
  RETURN v;
END;
/
SELECT prostatus FROM pg_proc WHERE proname like 'fun9'; --v
 prostatus 
-----------
 v
(1 row)

SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE c.relname like 't1'
  AND d.refobjid = c.oid
  AND d.objid = p.oid
  AND p.proname like 'fun9';  --1
 count 
-------
     1
(1 row)

CREATE OR REPLACE FUNCTION fun10() RETURN int AS
  a t1%ROWTYPE;
  b t1%ROWTYPE;
BEGIN
  RETURN v;
END;
/
SELECT prostatus FROM pg_proc WHERE proname like 'fun10'; --v
 prostatus 
-----------
 v
(1 row)

SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE c.relname like 't1'
  AND d.refobjid = c.oid
  AND d.objid = p.oid
  AND p.proname like 'fun10';  --1
 count 
-------
     1
(1 row)

CREATE OR REPLACE FUNCTION fun11(v t1%ROWTYPE, v1 t1%ROWTYPE) RETURN t1%ROWTYPE AS
  a t1%ROWTYPE;
  b t1%ROWTYPE;
BEGIN
  RETURN v;
END;
/
SELECT prostatus FROM pg_proc WHERE proname like 'fun11'; --v
 prostatus 
-----------
 v
(1 row)

SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE c.relname like 't1'
  AND d.refobjid = c.oid
  AND d.objid = p.oid
  AND p.proname like 'fun11'; --1
 count 
-------
     1
(1 row)

CREATE OR REPLACE FUNCTION fun12(v t1.id%TYPE, v1 t1.id%TYPE, v2 t1.name %TYPE, v3 t1.name%TYPE, v4 t1%ROWTYPE, v5 t1%ROWTYPE) RETURN t1.id%TYPE AS
  a t1.id%TYPE;
  b t1.name%TYPE;
  c t1%ROWTYPE;
BEGIN
  RETURN v;
END;
/
NOTICE:  type reference t1.id%TYPE converted to varchar2
NOTICE:  type reference t1.id%TYPE converted to varchar2
NOTICE:  type reference t1.name%TYPE converted to varchar2
NOTICE:  type reference t1.name%TYPE converted to varchar2
NOTICE:  type reference t1.id%TYPE converted to varchar2
SELECT prostatus FROM pg_proc WHERE proname like 'fun12'; --v
 prostatus 
-----------
 v
(1 row)

SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE c.relname like 't1' 
  AND d.refobjid = c.oid 
  AND d.objid = p.oid
  AND p.proname like 'fun12'; --2
 count 
-------
     2
(1 row)

DROP FUNCTION fun5;
DROP FUNCTION fun6;
DROP FUNCTION fun7;
DROP FUNCTION fun8;
DROP FUNCTION fun9;
DROP FUNCTION fun10;
DROP FUNCTION fun11;
DROP FUNCTION fun12;
--5.1.2
set check_function_bodies = on;
DROP TABLE t1;
CREATE TABLE t1(id varchar(20), name varchar(20));
CREATE OR REPLACE FUNCTION fun1(v t1.id%TYPE, v1 t1.id%TYPE) RETURN t1.id%TYPE AS
  id t1.name%TYPE;
BEGIN
  RETURN v;
END;
/
NOTICE:  type reference t1.id%TYPE converted to varchar2
NOTICE:  type reference t1.id%TYPE converted to varchar2
NOTICE:  type reference t1.id%TYPE converted to varchar2
SELECT prostatus FROM pg_proc WHERE proname like 'fun1'; --v
 prostatus 
-----------
 v
(1 row)

SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE d.refobjid = c.oid AND d.objid = p.oid; --2
 count 
-------
     2
(1 row)

SELECT fun1(2,2) FROM DUAL; --2
 fun1 
------
 2
(1 row)

ALTER FUNCTION fun1 COMPILE;
SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE d.refobjid = c.oid AND d.objid = p.oid; --2
 count 
-------
     2
(1 row)

CREATE OR REPLACE FUNCTION fun1(v t1.id%TYPE, v1 t1.id%TYPE) RETURN t1.id%TYPE AS
BEGIN
  RETURN v + 1;
END;
/
NOTICE:  type reference t1.id%TYPE converted to varchar2
NOTICE:  type reference t1.id%TYPE converted to varchar2
NOTICE:  type reference t1.id%TYPE converted to varchar2
SELECT prostatus FROM pg_proc WHERE proname like 'fun1'; --v
 prostatus 
-----------
 v
(1 row)

SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE d.refobjid = c.oid AND d.objid = p.oid; --1
 count 
-------
     1
(1 row)

SELECT fun1(2,2) FROM DUAL; --3
 fun1 
------
 3
(1 row)

  
ALTER FUNCTION fun1 COMPILE;
SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE d.refobjid = c.oid AND d.objid = p.oid; --1
 count 
-------
     1
(1 row)

SELECT fun1(2,2) FROM DUAL; --3
 fun1 
------
 3
(1 row)

\c 
SELECT fun1(2,2) FROM DUAL; --3
 fun1 
------
 3
(1 row)

--alter table t1 drop column id
ALTER TABLE T1 DROP COLUMN id;
SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE d.refobjid = c.oid AND d.objid = p.oid;  --0
 count 
-------
     0
(1 row)

SELECT fun1(3,3) FROM DUAL; --error
ERROR:  package, relation or view does not exist
LINE 1: SELECT fun1(3,3) FROM DUAL;
               ^
ALTER FUNCTION fun1 COMPILE; --should raise an error, because have dropped id column.
WARNING:  compilation error
HINT:  package, relation or view does not exist
SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE d.refobjid = c.oid AND d.objid = p.oid; --0
 count 
-------
     0
(1 row)

DROP FUNCTION fun1;
--5.2  when a function has invalid status, rebuild the function using CREATE OR REPLACE, and the function can have VALID status
DROP TABLE t1;
CREATE TABLE t1(id varchar(20), name varchar(20), id2 int);
					
CREATE OR REPLACE FUNCTION fun1(v t1.name%TYPE, v1 t1.name%TYPE) RETURN t1.name%TYPE AS
  id t1.id%TYPE;
BEGIN
  RETURN v;
END;
/
NOTICE:  type reference t1.name%TYPE converted to varchar2
NOTICE:  type reference t1.name%TYPE converted to varchar2
NOTICE:  type reference t1.name%TYPE converted to varchar2
ALTER TABLE T1 DROP COLUMN id;
SELECT prostatus FROM pg_proc WHERE proname like 'fun1'; --n
 prostatus 
-----------
 n
(1 row)

select fun1('a','b') from dual;  --error
ERROR:  column "id" of relation "t1" does not exist
CONTEXT:  compilation of PL/iSQL function "fun1" near line 1
CREATE OR REPLACE FUNCTION fun1(v t1.name%TYPE, v1 t1.name%TYPE) RETURN t1.name%TYPE AS
  id t1.id2%TYPE;
  id2 int;
BEGIN
  RETURN 'ab';
END;
/
NOTICE:  type reference t1.name%TYPE converted to varchar2
NOTICE:  type reference t1.name%TYPE converted to varchar2
NOTICE:  type reference t1.name%TYPE converted to varchar2
SELECT prostatus FROM pg_proc WHERE proname like 'fun1'; --v
 prostatus 
-----------
 v
(1 row)

select fun1('a','b') from dual;  --ab
 fun1 
------
 ab
(1 row)

DROP FUNCTION fun1;
--5.3 set check_function_bodies = off
set check_function_bodies = off;
DROP TABLE t1;
CREATE TABLE t1(id varchar(20), name varchar(20));
CREATE OR REPLACE FUNCTION fun1(v t1.id%TYPE, v1 t1.id%TYPE) RETURN t1.id%TYPE AS
  id t1.name%TYPE;
BEGIN
  RETURN v;
END;
/
NOTICE:  type reference t1.id%TYPE converted to varchar2
NOTICE:  type reference t1.id%TYPE converted to varchar2
NOTICE:  type reference t1.id%TYPE converted to varchar2
SELECT prostatus FROM pg_proc WHERE proname like 'fun1'; --n
 prostatus 
-----------
 n
(1 row)

SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE d.refobjid = c.oid AND d.objid = p.oid; --0
 count 
-------
     0
(1 row)

SELECT fun1(2,2);
 fun1 
------
 2
(1 row)

ALTER FUNCTION fun1 COMPILE;
SELECT fun1(2,2);
 fun1 
------
 2
(1 row)

SELECT prostatus FROM pg_proc WHERE proname like 'fun1'; --v
 prostatus 
-----------
 v
(1 row)

SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE d.refobjid = c.oid AND d.objid = p.oid; --2
 count 
-------
     2
(1 row)

SELECT fun1(2,2) FROM DUAL;  --2
 fun1 
------
 2
(1 row)

set check_function_bodies = off;
CREATE OR REPLACE FUNCTION fun1(v t1.id%TYPE, v1 t1.id%TYPE) RETURN t1.id%TYPE AS
BEGIN
  RETURN v + 1;
END;
/
NOTICE:  type reference t1.id%TYPE converted to varchar2
NOTICE:  type reference t1.id%TYPE converted to varchar2
NOTICE:  type reference t1.id%TYPE converted to varchar2
SELECT prostatus FROM pg_proc WHERE proname like 'fun1'; --n
 prostatus 
-----------
 n
(1 row)

SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE d.refobjid = c.oid AND d.objid = p.oid; --0
 count 
-------
     0
(1 row)

SELECT fun1(2,2) FROM DUAL; --3
 fun1 
------
 3
(1 row)

\c 
SELECT fun1(2,2) FROM DUAL; --3
 fun1 
------
 3
(1 row)

--alter table t1 drop column id
ALTER TABLE T1 DROP COLUMN id;
SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE d.refobjid = c.oid AND d.objid = p.oid; --0
 count 
-------
     0
(1 row)

SELECT fun1(3,3); --error
ERROR:  package, relation or view does not exist
LINE 1: SELECT fun1(3,3);
               ^
ALTER FUNCTION fun1 COMPILE; --should raise an error, because id column has been dropped.
WARNING:  compilation error
HINT:  package, relation or view does not exist
SELECT count(*) FROM pg_depend d, pg_class c, pg_proc p 
  WHERE d.refobjid = c.oid AND d.objid = p.oid; --0
 count 
-------
     0
(1 row)

DROP FUNCTION fun1;
DROP TABLE t1;
DROP VIEW view1;
DROP TABLE t1;
DROP TABLE t2;
RESET IVORYSQL.COMPATIBLE_MODE;
RESET IVORYSQL.IDENTIFIER_CASE_SWITCH;
--7 others
--7.1 parameter datatype of subprocedure in package is %TYPE or %ROWTYPE
create table tb1(id int,name varchar(5));
create or replace package pkg is
  var1 int;
  function test_f(id tb1.id%type) return integer;
end;
/
--successfully
create or replace package body pkg is
  function test_f(id tb1.id%type) return integer is
  begin
    return id;
  end;
end;
/
--failed
create or replace package body pkg is
  var2 varchar2(10);
  function test_f(id int) return integer is
  begin
    return id;
  end;
end;
/
ERROR:  subprogram or cursor 'test_f', is declared in a package specification and must be defined in the package body
CONTEXT:  compilation of PL/iSQL package "pkg" near line 6
drop package pkg;
create or replace package pkg is
  var1 int;
  function test_f(id tb1%rowtype) return integer;
end;
/
--successfully
create or replace package body pkg is
  function test_f(id tb1%rowtype) return integer is
  begin
    return id;
  end;
end;
/
--failed
create or replace package body pkg is
  function test_f(id tb1.id%type) return integer is
  begin
    return id;
  end;
end;
/
ERROR:  subprogram or cursor 'test_f', is declared in a package specification and must be defined in the package body
CONTEXT:  compilation of PL/iSQL package "pkg" near line 5
drop package pkg;
drop table tb1;
--7.2 guc plisql.extra_errors
create table tb1(id int,name varchar(5),age int);
insert into tb1 values(1,'sam',20);
insert into tb1 values(2,'amy',30);
create table tb2(id int,name varchar(5));
--successfully
declare
  var1 tb2%rowtype;
begin
  select * into var1 from tb1 where id=2;
end;
/
--successfully
declare
  var1 tb2%rowtype;
begin
  select id into var1 from tb1 where id=2;
end;
/
set plisql.extra_errors = 'all';
--failed
declare
  var1 tb2%rowtype;
begin
  select * into var1 from tb1 where id=2;
end;
/
ERROR:  number of source and target fields in assignment does not match
DETAIL:  strict_multi_assignment check of extra_errors is active.
HINT:  Make sure the query returns the exact list of columns.
CONTEXT:  PL/iSQL function inline_code_block line 4 at SQL statement
--failed
declare
  var1 tb2%rowtype;
begin
  select id into var1 from tb1 where id=2;
end;
/
ERROR:  number of source and target fields in assignment does not match
DETAIL:  strict_multi_assignment check of extra_errors is active.
HINT:  Make sure the query returns the exact list of columns.
CONTEXT:  PL/iSQL function inline_code_block line 4 at SQL statement
drop table tb2;
drop table tb1;
set plisql.extra_errors = 'none';
--7.3
create table tb1(id int, id2 float4, id3 float8, id4 number, name1 varchar(20), name2 char);
create function fun1(c1 tb1.id%type,c2 tb1.i2d%type, c3 tb1.id3%type, c4 tb1.id4%type, c5 tb1.name1%type, c6 tb1.name2%type) return tb1.name1%type is
begin
  return c5;
end;
/
NOTICE:  type reference tb1.id%TYPE converted to pg_catalog.int4
ERROR:  column "i2d" of relation "tb1" does not exist
create function fun1(c1 tb1.id%type,c2 tb1.id2%type, c3 tb1.id3%type, c4 tb1.id4%type, c5 tb1.name1%type, c6 tb1.name2%type) return tb1.name1%type is
begin
  return c5;
end;
/
NOTICE:  type reference tb1.id%TYPE converted to pg_catalog.int4
NOTICE:  type reference tb1.id2%TYPE converted to pg_catalog.float4
NOTICE:  type reference tb1.id3%TYPE converted to pg_catalog.float8
NOTICE:  type reference tb1.id4%TYPE converted to number
NOTICE:  type reference tb1.name1%TYPE converted to varchar2
NOTICE:  type reference tb1.name2%TYPE converted to char
NOTICE:  type reference tb1.name1%TYPE converted to varchar2
drop table tb1;
drop function fun1;
--7.4
create table tb1(id int, id2 float4, id3 float8, id4 number, name1 varchar(20), name2 char);
create or replace package pkg1 is
  var1 tb1.id%TYPE;
  FUNCTION fun1(c1 tb1.id%type,c2 tb1.id2%type, c3 tb1.id3%type, c4 tb1.id4%type, c5 tb1.name1%type, c6 tb1.name2%type) return tb1.name1%type;
END;
/
create or replace package body pkg1 is
  a tb1.name1%TYPE := 'a';
  FUNCTION fun1(c1 tb1.id%type,c2 tb1.id2%type, c3 tb1.id3%type, c4 tb1.id4%type, c5 tb1.name1%type, c6 tb1.name2%type) return tb1.name1%type AS
  BEGIN
    RETURN c5;
  END;
END;
/
drop table tb1;
drop package pkg1;
--7.5 failed to compile the functions in CREATE OR REPLACE FUNCTION/PROCEDURE statement
SET IVORYSQL.COMPATIBLE_MODE TO ORACLE;
SET IVORYSQL.IDENTIFIER_CASE_SWITCH = INTERCHANGE;
create or replace  function fun1(id int) return int as
begin
  return abc;
end;
/
SELECT prostatus FROM PG_PROC WHERE PRONAME LIKE 'fun1';
 prostatus 
-----------
 v
(1 row)

SELECT TEXT FROM SYS.ALL_SOURCE WHERE NAME LIKE 'FUN1';
                   text                   
------------------------------------------
 FUNCTION public.fun1(id pg_catalog.int4)
  RETURN pg_catalog.int4
  AUTHID DEFINER
 IS 
 begin
   return abc;
 end;
(7 rows)

SELECT object_name,package_name,subprogram_id,argument_name,position,sequence,data_level,data_type,defaulted,default_value,default_length,in_out,data_length,data_precision,data_scale,
  radix,type_name,type_subname,type_object_type,pls_type,char_length,char_used,origin_con_id FROM SYS.ALL_ARGUMENTS where OBJECT_NAME like 'FUN1';
 object_name | package_name | subprogram_id | argument_name | position | sequence | data_level | data_type | defaulted | default_value | default_length | in_out | data_length | data_precision | data_scale | radix | type_name | type_subname | type_object_type |    pls_type     | char_length | char_used | origin_con_id 
-------------+--------------+---------------+---------------+----------+----------+------------+-----------+-----------+---------------+----------------+--------+-------------+----------------+------------+-------+-----------+--------------+------------------+-----------------+-------------+-----------+---------------
 FUN1        |              | 1             |               | 0        | 1        | 0          | NUMBER    | N         |               |                | OUT    | 22          | 38             |            | 10    |           |              |                  | PG_CATALOG.INT4 | 0           | 0         | 0
 FUN1        |              | 1             | ID            | 1        | 2        | 0          | NUMBER    | N         |               |                | IN     | 22          | 38             |            | 10    |           |              |                  | PG_CATALOG.INT4 | 0           | 0         | 0
(2 rows)

SELECT object_name,procedure_name,subprogram_id,object_type,authid FROM ALL_PROCEDURES WHERE OBJECT_NAME like 'FUN1' ORDER BY object_name,procedure_name;
 object_name | procedure_name | subprogram_id | object_type | authid  
-------------+----------------+---------------+-------------+---------
 FUN1        |                | 1             | FUNCTION    | DEFINER
(1 row)

DROP FUNCTION fun1;
create or replace  function fun2(id int) return int as
begin
  return 1;
end;
/
SELECT prostatus FROM PG_PROC WHERE PRONAME LIKE 'fun2';
 prostatus 
-----------
 v
(1 row)

SELECT TEXT FROM SYS.ALL_SOURCE WHERE NAME LIKE 'FUN2';
                   text                   
------------------------------------------
 FUNCTION public.fun2(id pg_catalog.int4)
  RETURN pg_catalog.int4
  AUTHID DEFINER
 IS 
 begin
   return 1;
 end;
(7 rows)

SELECT object_name,package_name,subprogram_id,argument_name,position,sequence,data_level,data_type,defaulted,default_value,default_length,in_out,data_length,data_precision,data_scale,
  radix,type_name,type_subname,type_object_type,pls_type,char_length,char_used,origin_con_id FROM SYS.ALL_ARGUMENTS where OBJECT_NAME like 'FUN2';
 object_name | package_name | subprogram_id | argument_name | position | sequence | data_level | data_type | defaulted | default_value | default_length | in_out | data_length | data_precision | data_scale | radix | type_name | type_subname | type_object_type |    pls_type     | char_length | char_used | origin_con_id 
-------------+--------------+---------------+---------------+----------+----------+------------+-----------+-----------+---------------+----------------+--------+-------------+----------------+------------+-------+-----------+--------------+------------------+-----------------+-------------+-----------+---------------
 FUN2        |              | 1             |               | 0        | 1        | 0          | NUMBER    | N         |               |                | OUT    | 22          | 38             |            | 10    |           |              |                  | PG_CATALOG.INT4 | 0           | 0         | 0
 FUN2        |              | 1             | ID            | 1        | 2        | 0          | NUMBER    | N         |               |                | IN     | 22          | 38             |            | 10    |           |              |                  | PG_CATALOG.INT4 | 0           | 0         | 0
(2 rows)

SELECT object_name,procedure_name,subprogram_id,object_type,authid FROM ALL_PROCEDURES WHERE OBJECT_NAME like 'FUN2' ORDER BY object_name,procedure_name;
 object_name | procedure_name | subprogram_id | object_type | authid  
-------------+----------------+---------------+-------------+---------
 FUN2        |                | 1             | FUNCTION    | DEFINER
(1 row)

create or replace  function fun2(id int) return int as
begin
  a := 1;
  return a;
end;
/
WARNING:  compilation error
HINT:  "a" is not a known variable
SELECT prostatus FROM PG_PROC WHERE PRONAME LIKE 'fun2';
 prostatus 
-----------
 i
(1 row)

SELECT TEXT FROM ALL_SOURCE WHERE NAME LIKE 'FUN2';
                   text                   
------------------------------------------
 FUNCTION public.fun2(id pg_catalog.int4)
  RETURN pg_catalog.int4
  AUTHID DEFINER
 IS 
 begin
   a := 1;
   return a;
 end;
(8 rows)

SELECT object_name,package_name,subprogram_id,argument_name,position,sequence,data_level,data_type,defaulted,default_value,default_length,in_out,data_length,data_precision,data_scale,
  radix,type_name,type_subname,type_object_type,pls_type,char_length,char_used,origin_con_id FROM SYS.ALL_ARGUMENTS where OBJECT_NAME like 'FUN2';
 object_name | package_name | subprogram_id | argument_name | position | sequence | data_level | data_type | defaulted | default_value | default_length | in_out | data_length | data_precision | data_scale | radix | type_name | type_subname | type_object_type |    pls_type     | char_length | char_used | origin_con_id 
-------------+--------------+---------------+---------------+----------+----------+------------+-----------+-----------+---------------+----------------+--------+-------------+----------------+------------+-------+-----------+--------------+------------------+-----------------+-------------+-----------+---------------
 FUN2        |              | 1             |               | 0        | 1        | 0          | NUMBER    | N         |               |                | OUT    | 22          | 38             |            | 10    |           |              |                  | PG_CATALOG.INT4 | 0           | 0         | 0
 FUN2        |              | 1             | ID            | 1        | 2        | 0          | NUMBER    | N         |               |                | IN     | 22          | 38             |            | 10    |           |              |                  | PG_CATALOG.INT4 | 0           | 0         | 0
(2 rows)

SELECT object_name,procedure_name,subprogram_id,object_type,authid FROM ALL_PROCEDURES WHERE OBJECT_NAME like 'FUN2' ORDER BY object_name,procedure_name;
 object_name | procedure_name | subprogram_id | object_type | authid  
-------------+----------------+---------------+-------------+---------
 FUN2        |                | 1             | FUNCTION    | DEFINER
(1 row)

DROP FUNCTION fun2;
RESET IVORYSQL.COMPATIBLE_MODE;
RESET IVORYSQL.IDENTIFIER_CASE_SWITCH;
--
--clean up
DROP TABLE employees;
