--
-- ROWNUM
-- Test Oracle ROWNUM pseudocolumn functionality
--
-- Setup test data
CREATE TABLE rownum_test (
    id int,
    name varchar(50),
    value int
);
INSERT INTO rownum_test VALUES
    (1, 'Alice', 100),
    (2, 'Bob', 200),
    (3, 'Charlie', 150),
    (4, 'David', 300),
    (5, 'Eve', 250),
    (6, 'Frank', 175),
    (7, 'Grace', 225),
    (8, 'Henry', 125),
    (9, 'Iris', 275),
    (10, 'Jack', 190);
--
-- Basic ROWNUM queries
--
-- ROWNUM <= N (should use LIMIT optimization)
SELECT id, name FROM rownum_test WHERE ROWNUM <= 5;
 id |  name   
----+---------
  1 | Alice
  2 | Bob
  3 | Charlie
  4 | David
  5 | Eve
(5 rows)

-- ROWNUM = 1 (should use LIMIT 1)
SELECT id, name FROM rownum_test WHERE ROWNUM = 1;
 id | name  
----+-------
  1 | Alice
(1 row)

-- ROWNUM < N (should use LIMIT N-1)
SELECT id, name FROM rownum_test WHERE ROWNUM < 4;
 id |  name   
----+---------
  1 | Alice
  2 | Bob
  3 | Charlie
(3 rows)

-- ROWNUM in SELECT list
SELECT ROWNUM, id, name FROM rownum_test WHERE ROWNUM <= 3;
 rownum | id |  name   
--------+----+---------
      1 |  1 | Alice
      2 |  2 | Bob
      3 |  3 | Charlie
(3 rows)

--
-- ROWNUM with ORDER BY
-- (requires subquery pattern to order first, then limit)
--
-- Top-N by value (descending)
SELECT * FROM (
    SELECT id, name, value
    FROM rownum_test
    ORDER BY value DESC
) WHERE ROWNUM <= 3;
 id | name  | value 
----+-------+-------
  4 | David |   300
  9 | Iris  |   275
  5 | Eve   |   250
(3 rows)

-- Top-N by name (ascending)
SELECT * FROM (
    SELECT id, name
    FROM rownum_test
    ORDER BY name
) WHERE ROWNUM <= 5;
 id |  name   
----+---------
  1 | Alice
  2 | Bob
  3 | Charlie
  4 | David
  5 | Eve
(5 rows)

-- ROWNUM = 1 with ORDER BY (get minimum)
SELECT * FROM (
    SELECT id, name, value
    FROM rownum_test
    ORDER BY value
) WHERE ROWNUM = 1;
 id | name  | value 
----+-------+-------
  1 | Alice |   100
(1 row)

--
-- ROWNUM in nested subqueries
--
-- Subquery with ROWNUM in WHERE clause
SELECT name FROM (
    SELECT id, name FROM rownum_test WHERE ROWNUM <= 7
) sub WHERE id > 3;
 name  
-------
 David
 Eve
 Frank
 Grace
(4 rows)

-- Multiple levels of ROWNUM
SELECT * FROM (
    SELECT * FROM (
        SELECT id, name FROM rownum_test WHERE ROWNUM <= 8
    ) WHERE ROWNUM <= 5
) WHERE ROWNUM <= 3;
 id |  name   
----+---------
  1 | Alice
  2 | Bob
  3 | Charlie
(3 rows)

--
-- ROWNUM with JOINs
--
CREATE TABLE dept (
    dept_id int,
    dept_name varchar(50)
);
INSERT INTO dept VALUES
    (1, 'Engineering'),
    (2, 'Sales'),
    (3, 'Marketing');
-- Update test data to include dept_id
ALTER TABLE rownum_test ADD COLUMN dept_id int;
UPDATE rownum_test SET dept_id = (id % 3) + 1;
-- ROWNUM with JOIN
SELECT e.id, e.name, d.dept_name
FROM (SELECT * FROM rownum_test WHERE ROWNUM <= 5) e
JOIN dept d ON e.dept_id = d.dept_id
ORDER BY e.id;
 id |  name   |  dept_name  
----+---------+-------------
  1 | Alice   | Sales
  2 | Bob     | Marketing
  3 | Charlie | Engineering
  4 | David   | Sales
  5 | Eve     | Marketing
(5 rows)

-- JOIN with ORDER BY and ROWNUM
SELECT * FROM (
    SELECT e.id, e.name, e.value, d.dept_name
    FROM rownum_test e
    JOIN dept d ON e.dept_id = d.dept_id
    ORDER BY e.value DESC
) WHERE ROWNUM <= 4;
 id | name  | value |  dept_name  
----+-------+-------+-------------
  4 | David |   300 | Sales
  9 | Iris  |   275 | Engineering
  5 | Eve   |   250 | Marketing
  7 | Grace |   225 | Sales
(4 rows)

--
-- Edge cases and non-optimizable patterns
--
-- ROWNUM > 0 (tautology, returns all rows - Oracle semantics)
SELECT COUNT(*) FROM rownum_test WHERE ROWNUM > 0;
 count 
-------
    10
(1 row)

-- ROWNUM >= 1 (tautology, returns all rows - Oracle semantics)
SELECT COUNT(*) FROM rownum_test WHERE ROWNUM >= 1;
 count 
-------
    10
(1 row)

-- ROWNUM > N where N >= 1 (returns empty - Oracle semantics)
SELECT id, name FROM rownum_test WHERE ROWNUM > 5;
 id | name 
----+------
(0 rows)

SELECT COUNT(*) FROM rownum_test WHERE ROWNUM > 1;
 count 
-------
     0
(1 row)

-- ROWNUM >= N where N > 1 (returns empty - Oracle semantics)
SELECT id, name FROM rownum_test WHERE ROWNUM >= 2;
 id | name 
----+------
(0 rows)

SELECT COUNT(*) FROM rownum_test WHERE ROWNUM >= 2;
 count 
-------
     0
(1 row)

-- ROWNUM = 0 (always false)
SELECT id, name FROM rownum_test WHERE ROWNUM = 0;
 id | name 
----+------
(0 rows)

-- ROWNUM = 2 (not optimizable, returns empty - Oracle semantics)
SELECT id, name FROM rownum_test WHERE ROWNUM = 2;
 id | name 
----+------
(0 rows)

-- ROWNUM = 3 (not optimizable, returns empty - Oracle semantics)
SELECT id, name FROM rownum_test WHERE ROWNUM = 3;
 id | name 
----+------
(0 rows)

-- ROWNUM with negative number
SELECT id, name FROM rownum_test WHERE ROWNUM <= -1;
 id | name 
----+------
(0 rows)

-- ROWNUM in complex WHERE clause (AND)
SELECT id, name FROM rownum_test WHERE ROWNUM <= 5 AND id > 2;
 id |  name   
----+---------
  3 | Charlie
  4 | David
  5 | Eve
  6 | Frank
  7 | Grace
(5 rows)

-- ROWNUM in complex WHERE clause (OR - not optimizable)
SELECT id, name FROM rownum_test WHERE ROWNUM <= 3 OR id = 10;
 id |  name   
----+---------
  1 | Alice
  2 | Bob
  3 | Charlie
 10 | Jack
(4 rows)

--
-- ROWNUM with DISTINCT
--
SELECT DISTINCT dept_id FROM rownum_test WHERE ROWNUM <= 6;
 dept_id 
---------
       3
       2
       1
(3 rows)

--
-- ROWNUM with aggregate functions
--
-- ROWNUM with GROUP BY (applied before grouping)
SELECT dept_id, COUNT(*)
FROM (SELECT * FROM rownum_test WHERE ROWNUM <= 7)
GROUP BY dept_id
ORDER BY dept_id;
 dept_id | count 
---------+-------
       1 |     2
       2 |     3
       3 |     2
(3 rows)

--
-- Issue #12: ROWNUM with same-level ORDER BY, DISTINCT, GROUP BY, aggregation
-- These should NOT be transformed to LIMIT because of semantic differences
--
-- Direct COUNT with ROWNUM (should count only first 5 rows, not all rows)
SELECT COUNT(*) FROM rownum_test WHERE ROWNUM <= 5;
 count 
-------
     5
(1 row)

-- Direct ORDER BY with ROWNUM (should pick first 5 rows, THEN sort them)
-- NOT the same as "ORDER BY value LIMIT 5" which sorts all rows first
SELECT id, name, value FROM rownum_test WHERE ROWNUM <= 5 ORDER BY value;
 id |  name   | value 
----+---------+-------
  1 | Alice   |   100
  3 | Charlie |   150
  2 | Bob     |   200
  5 | Eve     |   250
  4 | David   |   300
(5 rows)

-- Direct DISTINCT with ROWNUM (should DISTINCT over first 3 rows only)
-- NOT the same as "SELECT DISTINCT ... LIMIT 3" which distincts all rows first
CREATE TABLE rownum_distinct_test (category varchar(10));
INSERT INTO rownum_distinct_test VALUES ('A'), ('A'), ('B'), ('B'), ('C'), ('C');
SELECT DISTINCT category FROM rownum_distinct_test WHERE ROWNUM <= 3;
 category 
----------
 B
 A
(2 rows)

DROP TABLE rownum_distinct_test;
-- Direct GROUP BY with ROWNUM (should group only first 4 rows)
-- NOT the same as "GROUP BY ... LIMIT N" which groups all rows first
CREATE TABLE rownum_group_test (category varchar(10), amount int);
INSERT INTO rownum_group_test VALUES
    ('A', 10), ('A', 20), ('B', 30), ('B', 40), ('C', 50), ('C', 60);
SELECT category, SUM(amount)
FROM rownum_group_test
WHERE ROWNUM <= 4
GROUP BY category
ORDER BY category;
 category | sum 
----------+-----
 A        |  30
 B        |  70
(2 rows)

DROP TABLE rownum_group_test;
--
-- Verify optimizer transformation with EXPLAIN
--
-- Should show Limit node for ROWNUM <= N
EXPLAIN (COSTS OFF) SELECT id, name FROM rownum_test WHERE ROWNUM <= 5;
          QUERY PLAN           
-------------------------------
 Limit
   ->  Seq Scan on rownum_test
(2 rows)

-- Should show Limit node for ROWNUM = 1
EXPLAIN (COSTS OFF) SELECT id, name FROM rownum_test WHERE ROWNUM = 1;
          QUERY PLAN           
-------------------------------
 Limit
   ->  Seq Scan on rownum_test
(2 rows)

-- Should show Limit node for ROWNUM < N
EXPLAIN (COSTS OFF) SELECT id, name FROM rownum_test WHERE ROWNUM < 4;
          QUERY PLAN           
-------------------------------
 Limit
   ->  Seq Scan on rownum_test
(2 rows)

-- Subquery pattern should show Limit node
EXPLAIN (COSTS OFF)
SELECT * FROM (
    SELECT id, name, value
    FROM rownum_test
    ORDER BY value DESC
) WHERE ROWNUM <= 3;
                QUERY PLAN                
------------------------------------------
 Limit
   ->  Sort
         Sort Key: rownum_test.value DESC
         ->  Seq Scan on rownum_test
(4 rows)

-- ROWNUM > 0 (tautology, should remove qual entirely)
EXPLAIN (COSTS OFF) SELECT COUNT(*) FROM rownum_test WHERE ROWNUM > 0;
          QUERY PLAN           
-------------------------------
 Aggregate
   ->  Seq Scan on rownum_test
(2 rows)

-- ROWNUM >= 1 (tautology, should remove qual entirely)
EXPLAIN (COSTS OFF) SELECT COUNT(*) FROM rownum_test WHERE ROWNUM >= 1;
          QUERY PLAN           
-------------------------------
 Aggregate
   ->  Seq Scan on rownum_test
(2 rows)

-- ROWNUM > 5 (should show One-Time Filter: false)
EXPLAIN (COSTS OFF) SELECT id, name FROM rownum_test WHERE ROWNUM > 5;
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

-- ROWNUM > 1 with aggregation (should show One-Time Filter: false)
EXPLAIN (COSTS OFF) SELECT COUNT(*) FROM rownum_test WHERE ROWNUM > 1;
           QUERY PLAN           
--------------------------------
 Aggregate
   ->  Result
         One-Time Filter: false
(3 rows)

-- ROWNUM >= 2 (should show One-Time Filter: false)
EXPLAIN (COSTS OFF) SELECT id, name FROM rownum_test WHERE ROWNUM >= 2;
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

-- ROWNUM = 2 should NOT be optimized to LIMIT (should show One-Time Filter: false)
EXPLAIN (COSTS OFF) SELECT id, name FROM rownum_test WHERE ROWNUM = 2;
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

-- Issue #12: These should NOT show Limit because of same-level operations
-- Direct COUNT with ROWNUM (has aggregation, should not use LIMIT)
EXPLAIN (COSTS OFF) SELECT COUNT(*) FROM rownum_test WHERE ROWNUM <= 5;
          QUERY PLAN           
-------------------------------
 Aggregate
   ->  Seq Scan on rownum_test
         Filter: (ROWNUM <= 5)
(3 rows)

-- Direct ORDER BY with ROWNUM (has ORDER BY, should not use LIMIT)
EXPLAIN (COSTS OFF) SELECT id, name FROM rownum_test WHERE ROWNUM <= 5 ORDER BY value;
          QUERY PLAN           
-------------------------------
 Sort
   Sort Key: value
   ->  Seq Scan on rownum_test
         Filter: (ROWNUM <= 5)
(4 rows)

-- Direct DISTINCT with ROWNUM (has DISTINCT, should not use LIMIT)
EXPLAIN (COSTS OFF) SELECT DISTINCT dept_id FROM rownum_test WHERE ROWNUM <= 5;
          QUERY PLAN           
-------------------------------
 HashAggregate
   Group Key: dept_id
   ->  Seq Scan on rownum_test
         Filter: (ROWNUM <= 5)
(4 rows)

--
-- ROWNUM with other clauses
--
-- ROWNUM with OFFSET (not standard Oracle, but test interaction)
SELECT id, name FROM rownum_test WHERE ROWNUM <= 5 OFFSET 2;
 id |  name   
----+---------
  3 | Charlie
  4 | David
  5 | Eve
  6 | Frank
  7 | Grace
(5 rows)

-- ROWNUM with FETCH FIRST (should work together)
SELECT id, name FROM rownum_test WHERE ROWNUM <= 8 FETCH FIRST 3 ROWS ONLY;
 id |  name   
----+---------
  1 | Alice
  2 | Bob
  3 | Charlie
(3 rows)

--
-- Cleanup
--
DROP TABLE rownum_test CASCADE;
DROP TABLE dept CASCADE;
